declare module "helios" {
    /**
     * @typedef {string & {}} hexstring
     */
    /**
     * Needed by transfer() methods
     * @typedef {{
     *   transferByteArrayData: (bytes: number[]) => any,
     *   transferConstrData: (index: number, fields: any[]) => any,
     *   transferIntData: (value: bigint) => any,
     *   transferListData: (items: any[]) => any,
     *   transferMapData: (pairs: [any, any][]) => any,
     *   transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any,
     *   transferSource: (raw: string, name: string) => any,
     *   transferUplcBool: (site: any, value: boolean) => any,
     *   transferUplcBuiltin: (site: any, name: string | number) => any,
     *   transferUplcByteArray: (site: any, bytes: number[]) => any,
     *   transferUplcCall: (site: any, a: any, b: any) => any,
     *   transferUplcConst: (value: any) => any,
     *   transferUplcDataValue: (site: any, data: any) => any,
     *   transferUplcDelay: (site: any, expr: any) => any,
     *   transferUplcError: (site: any, msg: string) => any,
     *   transferUplcForce: (site: any, expr: any) => any,
     *   transferUplcInt: (site: any, value: bigint, signed: boolean) => any,
     *   transferUplcLambda: (site: any, rhs: any, name: null | string) => any,
     *   transferUplcList: (site: any, itemType: any, items: any[]) => any,
     *   transferUplcPair: (site: any, first: any, second: any) => any,
     *   transferUplcString: (site: any, value: string) => any,
     *   transferUplcType: (typeBits: string) => any,
     *   transferUplcUnit: (site: any) => any,
     *   transferUplcVariable: (site: any, index: any) => any
     * }} TransferUplcAst
     */
    /**
     * Throws an error if 'cond' is false.
     * @internal
     * @param {boolean} cond
     * @param {string} msg
     */
    export function assert(cond: boolean, msg?: string): void;
    /**
     * Throws an error if 'obj' is undefined. Returns 'obj' itself (for chained application).
     * @internal
     * @template T
     * @param {T | undefined | null} obj
     * @param {string} msg
     * @returns {T}
     */
    export function assertDefined<T>(obj: T, msg?: string): T;
    /**
     * @internal
     * @template Tin, Tout
     * @param {Tin} obj
     * @param {{new(...any): Tout}} C
     * @returns {Tout}
     */
    export function assertClass<Tin, Tout>(obj: Tin, C: new (...any: any[]) => Tout, msg?: string): Tout;
    /**
     * @internal
     * @param {string} str
     * @param {string} msg
     * @returns {string}
     */
    export function assertNonEmpty(str: string, msg?: string): string;
    /**
     * @internal
     * @param {any} obj
     * @param {string} msg
     * @returns {number}
     */
    export function assertNumber(obj: any, msg?: string): number;
    /**
     * @internal
     * @template T
     * @param {(T | null)[]} lst
     * @returns {null | (T[])}
     */
    export function reduceNull<T>(lst: T[]): T[];
    /**
     * @internal
     * @template Ta
     * @template Tb
     * @param {[Ta | null, Tb | null][]} pairs
     * @returns {null | [Ta, Tb][]}
     */
    export function reduceNullPairs<Ta, Tb>(pairs: [Ta, Tb][]): [Ta, Tb][];
    /**
     * Compares two objects (deep recursive comparison)
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @returns {boolean}
     */
    export function eq<T>(a: T, b: T): boolean;
    /**
     * Throws an error if two object aren't equal (deep comparison).
     * Used by unit tests that are autogenerated from JSDoc inline examples.
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @param {string} msg
     */
    export function assertEq<T>(a: T, b: T, msg: string): void;
    /**
     * Divides two integers. Assumes a and b are whole numbers. Rounds down the result.
     * @example
     * idiv(355, 113) => 3
     * @internal
     * @param {number} a
     * @param {number} b
     */
    export function idiv(a: number, b: number): number;
    /**
     * 2 to the power 'p' for bigint.
     * @internal
     * @param {bigint} p
     * @returns {bigint}
     */
    export function ipow2(p: bigint): bigint;
    /**
     * Masks bits of 'b' by setting bits outside the range ['i0', 'i1') to 0.
     * 'b' is an 8 bit integer (i.e. number between 0 and 255).
     * The return value is also an 8 bit integer, shift right by 'i1'.
     
     * @example
     * imask(0b11111111, 1, 4) => 0b0111 // (i.e. 7)
     * @internal
     * @param {number} b
     * @param {number} i0
     * @param {number} i1
     * @returns {number}
     */
    export function imask(b: number, i0: number, i1: number): number;
    /**
     * Make sure resulting number fits in uint8
     * @internal
     * @param {number} x
     */
    export function imod8(x: number): number;
    /**
     * Converts an unbounded integer into a list of uint8 numbers (big endian)
     * Used by the CBOR encoding of data structures, and by Ed25519
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToBytes(x: bigint): number[];
    /**
     * Converts a list of uint8 numbers into an unbounded int (big endian)
     * Used by the CBOR decoding of data structures.
     * @internal
     * @param {number[]} b
     * @return {bigint}
     */
    export function bytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {number[]} b
     * @returns {bigint}
     */
    export function leBytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToLe32Bytes(x: bigint): number[];
    /**
     * Prepends zeroes to a bit-string so that 'result.length == n'.
     * @example
     * padZeroes("1111", 8) => "00001111"
     * @internal
     * @param {string} bits
     * @param {number} n
     * @returns {string}
     */
    export function padZeroes(bits: string, n: number): string;
    /**
     * Converts a 8 bit integer number into a bit string with an optional "0b" prefix.
     * The result is padded with leading zeroes to become 'n' chars long ('2 + n' chars long if you count the "0b" prefix).
     * @example
     * byteToBitString(7) => "0b00000111"
     * @internal
     * @param {number} b
     * @param {number} n
     * @param {boolean} prefix
     * @returns {string}
     */
    export function byteToBitString(b: number, n?: number, prefix?: boolean): string;
    /**
     * Converts a hexadecimal representation of bytes into an actual list of uint8 bytes.
     * @example
     * hexToBytes("00ff34") => [0, 255, 52]
     * @param {hexstring} hex
     * @returns {number[]}
     */
    export function hexToBytes(hex: hexstring): number[];
    /**
     * Converts a list of uint8 bytes into its hexadecimal string representation.
     * @example
     * bytesToHex([0, 255, 52]) => "00ff34"
     * @param {number[]} bytes
     * @returns {hexstring}
     */
    export function bytesToHex(bytes: number[]): hexstring;
    /**
     * Encodes a string into a list of uint8 bytes using UTF-8 encoding.
     * @example
     * textToBytes("hello world") => [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]
     * @param {string} str
     * @returns {number[]}
     */
    export function textToBytes(str: string): number[];
    /**
     * Decodes a list of uint8 bytes into a string using UTF-8 encoding.
     * @example
     * bytesToText([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]) => "hello world"
     * @param {number[]} bytes
     * @returns {string}
     */
    export function bytesToText(bytes: number[]): string;
    /**
     * Replaces the tab characters of a string with spaces.
     * This is used to create a prettier IR (which is built-up from many template js strings in this file, which might contain tabs depending on the editor used)
     * @example
     * replaceTabs("\t\t\t") => [TAB, TAB, TAB].join("")
     * @internal
     * @param {string} str
     * @returns {string}
     */
    export function replaceTabs(str: string): string;
    /**
     * A tag function for a helios source.
     * Is just a marker so IDE support can work on literal helios sources inside javascript/typescript files.
     * @example
     * hl`hello ${"world"}!` => "hello world!"
     * @param {string[]} a
     * @param  {...any} b
     * @returns {string}
     */
    export function hl(a: string[], ...b: any[]): string;
    /**
     * Display a warning message that a certain feature will be deprecated at some point in the future.
     * @internal
     * @param {string} feature
     * @param {string} futureVersion
     * @param {string} alternative
     * @param {string} docUrl
     */
    export function deprecationWarning(feature: string, futureVersion: string, alternative: string, docUrl?: string): void;
    /**
     * @internal
     * @param {undefined | null | Token} t
     * @param {Site} site
     * @param {string} msg
     * @returns {null | Token}
     */
    export function assertToken(t: undefined | null | Token, site: Site, msg?: string): null | Token;
    /**
     * Changes the value of BLAKE2B_DIGEST_SIZE
     *  (because the nodejs crypto module only supports
     *   blake2b-512 and not blake2b-256, and we want to avoid non-standard dependencies in the
     *   test-suite)
     * @internal
     * @param {number} s - 32 or 64
     */
    export function setBlake2bDigestSize(s: number): void;
    /**
     * @internal
     * @param {NumberGenerator} random
     * @param {number} n
     * @returns {number[]}
     */
    export function randomBytes(random: NumberGenerator, n: number): number[];
    /**
     * Dynamically constructs a new List class, depending on the item type.
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} ItemClass
     * @returns {HeliosDataClass<HList_>}
     */
    export function HList<T extends HeliosData>(ItemClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {T[]}
         */
        "__#1@#items": T[];
        /**
         * @internal
         * @type {string}
         */
        readonly _listTypeName: string;
        /**
         * @type {T[]}
         */
        readonly items: T[];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} TKey
     * @template {HeliosData} TValue
     * @param {HeliosDataClass<TKey>} KeyClass
     * @param {HeliosDataClass<TValue>} ValueClass
     * @returns {HeliosDataClass<HMap_>}
     */
    export function HMap<TKey extends HeliosData, TValue extends HeliosData>(KeyClass: HeliosDataClass<TKey>, ValueClass: HeliosDataClass<TValue>): HeliosDataClass<{
        /**
         * @type {[TKey, TValue][]}
         */
        "__#2@#pairs": [TKey, TValue][];
        /**
         * @internal
         * @type {string}
         */
        readonly _mapTypeName: string;
        /**
         * @type {[TKey, TValue][]}
         */
        readonly pairs: [TKey, TValue][];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} SomeClass
     * @returns {HeliosDataClass<Option_>}
     */
    export function Option<T extends HeliosData>(SomeClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {?T}
         */
        "__#3@#value": T;
        /**
         * @internal
         * @type {string}
         */
        readonly _optionTypeName: string;
        /**
         * @type {?T}
         */
        readonly some: T;
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * Use this function to check cost-model parameters
     * @internal
     * @param {NetworkParams} networkParams
     */
    export function dumpCostModels(networkParams: NetworkParams): void;
    /**
     * Returns index of a named builtin
     * Throws an error if builtin doesn't exist
     * @internal
     * @param {string} name
     * @returns
     */
    export function findUplcBuiltin(name: string): number;
    /**
     * Checks if a named builtin exists
     * @internal
     * @param {string} name
     * @param {boolean} strict - if true then throws an error if builtin doesn't exist
     * @returns {boolean}
     */
    export function isUplcBuiltin(name: string, strict?: boolean): boolean;
    /**
     * @internal
     * @typedef {UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv} CekValue
     */
    /**
     * @internal
     * @typedef {{
     * 	 values: CekValue[],
     *   callSites: Site[]
     * }} CekEnv
     */
    /**
     * @internal
     * @typedef {{computing: UplcTerm, env: CekEnv}} ComputingState
     */
    /**
     * @internal
     * @typedef {{reducing: CekValue}} ReducingState
     */
    /**
     * @internal
     * @typedef {{error: string | RuntimeError, env: CekEnv}} ErrorState
     */
    /**
     * @internal
     * @typedef {ComputingState | ReducingState | ErrorState} CekState
     */
    /**
     * @internal
     * @param {UplcRte} rte
     * @param {UplcTerm} start
     * @param {null | UplcValue[]} args
     * @returns {Promise<UplcValue>}
     */
    export function evalCek(rte: UplcRte, start: UplcTerm, args?: null | UplcValue[]): Promise<UplcValue>;
    /**
     * @param {number[]} bytes
     * @param {ProgramProperties} properties
     * @returns {UplcProgram}
     */
    export function deserializeUplcBytes(bytes: number[], properties?: ProgramProperties): UplcProgram;
    /**
     * Parses a plutus core program. Returns a UplcProgram object
     * @param {string} jsonString
     * @returns {UplcProgram}
     */
    export function deserializeUplc(jsonString: string): UplcProgram;
    /**
     * Tokenizes a string (wrapped in Source)
     * Also used by VSCode plugin
     * @internal
     * @param {Source} src
     * @returns {Token[] | null}
     */
    export function tokenize(src: Source): Token[] | null;
    /**
     * Tokenizes an IR string with a codemap to the original source
     * @internal
     * @param {string} rawSrc
     * @param {CodeMap} codeMap
     * @returns {Token[]}
     */
    export function tokenizeIR(rawSrc: string, codeMap: CodeMap): Token[];
    /**
     * @template {HeliosData} T
     */
    /**
     * @internal
     * @typedef {{
     *   type:  string
     * } | {
     *   type:     "List"
     *   itemType: TypeSchema
     * } | {
     *   type:      "Map"
     *   keyType:   TypeSchema
     *   valueType: TypeSchema
     * } | {
     *   type:     "Option"
     *   someType: TypeSchema
     * } | {
     *   type:       "Struct"
     *   fieldTypes: NamedTypeSchema[]
     * } | {
     *   type:         "Enum"
     *   variantTypes: {name: string, fieldTypes: NamedTypeSchema[]}[]
     * }} TypeSchema
     */
    /**
     * @internal
     * @typedef {{
     * 	 name: string
     * } & TypeSchema} NamedTypeSchema
     */
    /**
     * @internal
     * @typedef {{
     *   name: string
     *   typeClass: TypeClass
     * }} ParameterI
     */
    /**
     * @internal
     * @typedef {Map<ParameterI, Type>} InferenceMap
     */
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     * @internal
     * @typedef {{
     *   inputType:    string
     *   outputType:   string
     *   internalType: TypeSchema
     * }} TypeDetails
     */
    /**
     * @internal
     * @typedef {{[name: string]: (obj: any) => Promise<UplcData>}} JsToUplcHelpers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (data: UplcData) => Promise<any>}} UplcToJsHelpers
     */
    /**
     * @internal
     * @typedef {(obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>} JsToUplcConverter
     */
    /**
     * @internal
     * @typedef {(data: UplcData, helpers: UplcToJsHelpers) => Promise<any>} UplcToJsConverter
     */
    /**
     * @internal
     * @typedef {Named & Type & {
     *   asDataType:   DataType
     *   fieldNames:   string[]
     *   offChainType: (null | HeliosDataClass<HeliosData>)
     *   typeDetails?: TypeDetails
     *   jsToUplc:     JsToUplcConverter
     *   uplcToJs:     UplcToJsConverter
     *   ready:        boolean
     * }} DataType
     */
    /**
     * @internal
     * @typedef {DataType & {
     *   asEnumMemberType: EnumMemberType
     *   constrIndex:      number
     *   parentType:       DataType
     * }} EnumMemberType
     */
    /**
     * EvalEntities assert themselves
     * @internal
     * @typedef {{
     *   asDataType:       (null | DataType)
     *   asEnumMemberType: (null | EnumMemberType)
     *   asFunc:           (null | Func)
     *   asInstance:       (null | Instance)
     *   asMulti:          (null | Multi)
     *   asNamed:          (null | Named)
     *   asNamespace:      (null | Namespace)
     *   asParametric:     (null | Parametric)
     * 	 asType:           (null | Type)
     *   asTyped:          (null | Typed)
     *   asTypeClass:      (null | TypeClass)
     *   toString():       string
     * }} EvalEntity
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asFunc: Func
     * 	 funcType: FuncType
     *   call(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}): (null | Typed | Multi)
     * }} Func
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asInstance:      Instance
     *   fieldNames:      string[]
     *   instanceMembers: InstanceMembers
     * }} Instance
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *	 asMulti: Multi
     *   values:  Typed[]
     * }} Multi
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamed: Named
     *   name:    string
     *   path:    string
     * }} Named
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamespace: Namespace
     *   namespaceMembers: NamespaceMembers
     * }} Namespace
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asParametric: Parametric
     *   offChainType: (null | ((...any) => HeliosDataClass<HeliosData>))
     *   typeClasses: TypeClass[]
     *   apply(types: Type[], site?: Site): EvalEntity
     *   inferCall(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}, paramTypes?: Type[]): Func
     * 	 infer(site: Site, map: InferenceMap): Parametric
     * }} Parametric
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asType:               Type
     *   instanceMembers:      InstanceMembers
     *   typeMembers:          TypeMembers
     *   isBaseOf(type: Type): boolean
     *   infer(site: Site, map: InferenceMap, type: null | Type): Type
     *   toTyped():            Typed
     *   isParametric():       boolean
     * }} Type
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTyped: Typed
     *   type: Type
     * }} Typed
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTypeClass:                        TypeClass
     *   genInstanceMembers(impl: Type):     TypeClassMembers
     *   genTypeMembers(impl: Type):         TypeClassMembers
     *   isImplementedBy(type: Type):        boolean
     *   toType(name: string, path: string, parameter?: null | ParameterI): Type
     * }} TypeClass
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type)}} InstanceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: EvalEntity}} NamespaceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type | Typed)}} TypeMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: Type}} TypeClassMembers
     */
    /**
     * @internal
     * @param {Parametric} parametric
     * @param {Type[]} types
     * @returns {DataType}
     */
    export function applyTypes(parametric: Parametric, ...types: Type[]): DataType;
    /**
     * @internal
     * @param {Type} type
     * @returns {InstanceMembers}
     */
    export function genCommonInstanceMembers(type: Type): InstanceMembers;
    /**
     * @internal
     * @param {Type} type
     * @returns {TypeMembers}
     */
    export function genCommonTypeMembers(type: Type): TypeMembers;
    /**
     * @internal
     * @param {Type} type
     * @param {Type} parentType
     * @returns {TypeMembers}
     */
    export function genCommonEnumTypeMembers(type: Type, parentType: Type): TypeMembers;
    /**
     * @internal
     * @param {Type[]} itemTypes
     * @returns {Type}
     */
    export function IteratorType$(itemTypes: Type[]): Type;
    /**
     * @internal
     * @param {Type} itemType
     * @returns {DataType}
     */
    export function ListType$(itemType: Type): DataType;
    /**
     * @internal
     * @param {Type} keyType
     * @param {Type} valueType
     * @returns {DataType}
     */
    export function MapType$(keyType: Type, valueType: Type): DataType;
    /**
     * @internal
     * @param {Type} someType
     * @returns {DataType}
     */
    export function OptionType$(someType: Type): DataType;
    /**
     * Used by VSCode plugin and CLI
     * The sources can't be modified directly because that messes up the codemapping
     * @internal
     * @param {(path: StringLiteral) => (string | null)} fn
     */
    export function setImportPathTranslator(fn: (path: StringLiteral) => (string | null)): void;
    /**
     * @internal
     * @param {Token[]} ts
     * @returns {Statement[]}
     */
    export function buildProgramStatements(ts: Token[]): Statement[];
    /**
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[ScriptPurpose, Word] | null} - [purpose, name] (ScriptPurpose is an integer)
     * @internal
     */
    export function buildScriptPurpose(ts: Token[], expectedPurpose?: null | ScriptPurpose): [ScriptPurpose, Word] | null;
    /**
     * Also used by VSCode plugin
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[null | ScriptPurpose, Word | null, Statement[], number]}
     */
    export function buildScript(ts: Token[], expectedPurpose?: null | ScriptPurpose): [null | ScriptPurpose, Word | null, Statement[], number];
    /**
     * Parses Helios quickly to extract the script purpose header.
     * Returns null if header is missing or incorrectly formed (instead of throwing an error)
     * @param {string} rawSrc
     * @returns {null | [ScriptPurpose, string]} - [purpose, name]
     */
    export function extractScriptPurposeAndName(rawSrc: string): null | [ScriptPurpose, string];
    /**
     * Set the statistics collector (used by the test-suite)
     * @internal
     * @param {(name: string, count: number) => void} callback
     */
    export function setRawUsageNotifier(callback: (name: string, count: number) => void): void;
    /**
     * Load all raw generics so all possible implementations can be generated correctly during type parameter injection phase
     * @internal
     * @returns {IRDefinitions}
     */
    export function fetchRawGenerics(): IRDefinitions;
    /**
     * Doesn't add templates
     * @internal
     * @param {IR} ir
     * @param {null | IRDefinitions} userDefs - some userDefs might have the __helios prefix
     * @returns {IRDefinitions}
     */
    export function fetchRawFunctions(ir: IR, userDefs?: null | IRDefinitions): IRDefinitions;
    /**
     * @internal
     * @param {IR} ir
     * @returns {IR}
     */
    export function wrapWithRawFunctions(ir: IR): IR;
    /**
     * Build an Intermediate Representation expression
     * @param {Token[]} ts
     * @returns {IRExpr}
     * @internal
     */
    export function buildIRExpr(ts: Token[]): IRExpr;
    /**
     * Applies syntax highlighting by returning a list of char categories.
     * Not part of Tokeizer because it needs to be very fast and can't throw errors.
     * Doesn't depend on any other functions so it can easily be ported to other languages.
     * @param {string} src
     * @returns {Uint8Array}
     */
    export function highlight(src: string): Uint8Array;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplcInternal(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplc(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {UplcData} data
     * @param {UplcToJsHelpers} helpers
     * @returns {Promise<any>}
     */
    export function uplcToJs(schema: TypeSchema, data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
    /**
     * Version of the Helios library.
     */
    export const VERSION: "0.15.0";
    /**
     * A tab used for indenting of the IR.
     * 2 spaces.
     * @internal
     * @type {string}
     */
    export const TAB: string;
    /**
     * A Real in Helios is a fixed point number with REAL_PRECISION precision
     * @internal
     * @type {number}
     */
    export const REAL_PRECISION: number;
    /**
     * Modifiable config vars
     * @type {{
     *   DEBUG: boolean
     *   STRICT_BABBAGE: boolean
     *   IS_TESTNET: boolean
     *   N_DUMMY_INPUTS: number
     *   AUTO_SET_VALIDITY_RANGE: boolean
     *   VALIDITY_RANGE_START_OFFSET: number | null
     *   VALIDITY_RANGE_END_OFFSET: number | null
     *   EXPERIMENTAL_CEK: boolean
     *   IGNORE_UNEVALUATED_CONSTANTS: boolean
     * }}
     */
    export const config: {
        DEBUG: boolean;
        STRICT_BABBAGE: boolean;
        IS_TESTNET: boolean;
        N_DUMMY_INPUTS: number;
        AUTO_SET_VALIDITY_RANGE: boolean;
        VALIDITY_RANGE_START_OFFSET: number | null;
        VALIDITY_RANGE_END_OFFSET: number | null;
        EXPERIMENTAL_CEK: boolean;
        IGNORE_UNEVALUATED_CONSTANTS: boolean;
    };
    /**
     * Read non-byte aligned numbers
     * @internal
     */
    export class BitReader {
        /**
         * @param {number[]} bytes
         * @param {boolean} truncate - if true then read last bits as low part of number, if false pad with zero bits
         */
        constructor(bytes: number[], truncate?: boolean);
        /**
         * @internal
         * @returns {boolean}
         */
        eof(): boolean;
        /**
         * Reads a number of bits (<= 8) and returns the result as an unsigned number
         * @internal
         * @param {number} n - number of bits to read
         * @returns {number}
         */
        readBits(n: number): number;
        /**
         * Moves position to next byte boundary
         * @internal
         * @param {boolean} force - if true then move to next byte boundary if already at byte boundary
         */
        moveToByteBoundary(force?: boolean): void;
        /**
         * Reads 8 bits
         * @internal
         * @returns {number}
         */
        readByte(): number;
        /**
         * Dumps remaining bits we #pos isn't yet at end.
         * This is intended for debugging use.
         * @internal
         */
        dumpRemainingBits(): void;
        #private;
    }
    /**
     * BitWriter turns a string of '0's and '1's into a list of bytes.
     * Finalization pads the bits using '0*1' if not yet aligned with the byte boundary.
     * @internal
     */
    export class BitWriter {
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Write a string of '0's and '1's to the BitWriter.
         * @internal
         * @param {string} bitChars
         */
        write(bitChars: string): void;
        /**
         * @internal
         * @param {number} byte
         */
        writeByte(byte: number): void;
        /**
         * Add padding to the BitWriter in order to align with the byte boundary.
         * If 'force == true' then 8 bits are added if the BitWriter is already aligned.
         * @internal
         * @param {boolean} force
         */
        padToByteBoundary(force?: boolean): void;
        /**
         * Pop n bits of the end
         * @param {number} n
         * @returns {string}
         */
        pop(n: number): string;
        /**
         * Pads the BitWriter to align with the byte boundary and returns the resulting bytes.
         * @internal
         * @param {boolean} force - force padding (will add one byte if already aligned)
         * @returns {number[]}
         */
        finalize(force?: boolean): number[];
        #private;
    }
    /**
     * Function that generates a random number between 0 and 1
     * @typedef {() => number} NumberGenerator
     */
    /**
     * A Source instance wraps a string so we can use it cheaply as a reference inside a Site.
     * Also used by VSCode plugin
     */
    export class Source {
        /**
         * @param {string} raw
         * @param {string} name
         */
        constructor(raw: string, name: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @internal
         * @type {string}
         */
        get raw(): string;
        /**
         * @internal
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Error[]}
         */
        get errors(): Error[];
        throwErrors(): void;
        /**
         * Get char from the underlying string.
         * Should work fine utf-8 runes.
         * @internal
         * @param {number} pos
         * @returns {string}
         */
        getChar(pos: number): string;
        /**
         * Returns word under pos
         * @internal
         * @param {number} pos
         * @returns {?string}
         */
        getWord(pos: number): string | null;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Calculates the line number of the line where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {number}
         */
        posToLine(pos: number): number;
        /**
         * Calculates the column and line number where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {[number, number]}
         */
        posToLineAndCol(pos: number): [number, number];
        /**
         * Creates a more human-readable version of the source by prepending the line-numbers to each line.
         * The line-numbers are at least two digits.
         * @example
         * (new Source("hello\nworld")).pretty() => "01  hello\n02  world"
         * @internal
         * @returns {string}
         */
        pretty(): string;
        #private;
    }
    /**
     * Each Token/Expression/Statement has a Site, which encapsulates a position in a Source
     */
    export class Site {
        static dummy(): Site;
        /**
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {Site | null} codeMapSite
         */
        constructor(src: Source, startPos: number, endPos?: number, codeMapSite?: Site | null);
        /**
         *
         * @param {TransferUplcAst} other
         */
        transfer(other: TransferUplcAst): any;
        get src(): Source;
        get startPos(): number;
        get endPos(): number;
        get endSite(): Site;
        /**
         * @param {Site} other
         * @returns {Site}
         */
        merge(other: Site): Site;
        /**
         * @param {?Site} site
         */
        setEndSite(site: Site | null): void;
        /**
         * @type {?Site}
         */
        get codeMapSite(): Site;
        /**
         * @param {Site} site
         */
        setCodeMapSite(site: Site): void;
        /**
         * Returns a SyntaxError
         * @param {string} info
         * @returns {UserError}
         */
        syntaxError(info?: string): UserError;
        /**
         * Returns a TypeError
         * @param {string} info
         * @returns {UserError}
         */
        typeError(info?: string): UserError;
        /**
         * Returns a ReferenceError
         * @param {string} info
         * @returns {UserError}
         */
        referenceError(info?: string): UserError;
        /**
         * Calculates the column,line position in 'this.#src'
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * UserErrors are generated when the user of Helios makes a mistake (eg. a syntax error),
     * or when the user of Helios throws an explicit error inside a script (eg. division by zero).
     */
    export class UserError extends Error {
        /**
         * @internal
         * @param {string} type
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         */
        static new(type: string, src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a SyntaxError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static syntaxError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a TypeError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static typeError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isTypeError(e: Error): boolean;
        /**
         * Constructs a ReferenceError (i.e. name undefined, or name unused)
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static referenceError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isReferenceError(e: Error): boolean;
        /**
         * Catches any UserErrors thrown inside 'fn()`.
         * Dumps the error
         * @template T
         * @param {() => T} fn
         * @param {boolean} verbose
         * @returns {T | undefined}
         */
        static catch<T>(fn: () => T, verbose?: boolean): T;
        /**
         * @internal
         * @param {string} msg
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         */
        constructor(msg: string, src: Source, startPos: number, endPos?: number);
        /**
         * @internal
         * @type {Source}
         */
        get src(): Source;
        /**
         * @internal
         * @type {Object}
         */
        get context(): any;
        /**
         * @internal
         */
        get data(): void;
        /**
         * @internal
         * @type {number}
         */
        get startPos(): number;
        /**
         * Calculates column/line position in 'this.src'.
         * @internal
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * Dumps the error without throwing.
         * If 'verbose == true' the Source is also pretty printed with line-numbers.
         * @internal
         * @param {boolean} verbose
         */
        dump(verbose?: boolean): void;
        #private;
    }
    /**
     * Used for errors thrown during Uplc evaluation
     */
    export class RuntimeError extends Error {
        /**
         * @internal
         * @param {string} msg
         */
        constructor(msg: string);
        get context(): any;
        #private;
    }
    /**
     * Token is the base class of all Expressions and Statements
     * @internal
     */
    export class Token {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Returns 'true' if 'this' is a literal primitive, a literal struct constructor, or a literal function expression.
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * Returns 'true' if 'this' is a Word token.
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isWord(value?: (string | string[]) | null): boolean;
        /**
         * @returns {boolean}
         */
        isKeyword(): boolean;
        /**
         * Returns 'true' if 'this' is a Symbol token (eg. '+', '(' etc.)
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isSymbol(value?: (string | string[]) | null): boolean;
        /**
         * Returns 'true' if 'this' is a group (eg. '(...)').
         * @param {?string} value
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(value: string | null, nFields?: number | null): boolean;
        /**
         * Returns a SyntaxError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        syntaxError(msg: string): UserError;
        /**
         * Returns a TypeError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        typeError(msg: string): UserError;
        /**
         * Returns a ReferenceError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        referenceError(msg: string): UserError;
        /**
         * Throws a SyntaxError if 'this' isn't a Word.
         * @param {?(string | string[])} value
         * @returns {Word | null}
         */
        assertWord(value?: (string | string[]) | null): Word | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Symbol.
         * @param {?(string | string[])} value
         * @returns {SymbolToken | null}
         */
        assertSymbol(value?: (string | string[]) | null): SymbolToken | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Group.
         * @param {?string} type
         * @param {?number} nFields
         * @returns {Group | null}
         */
        assertGroup(type?: string | null, nFields?: number | null): Group | null;
        #private;
    }
    /**
     * A Word token represents a token that matches /[A-Za-z_][A-Za-z_0-9]/
     * @internal
     */
    export class Word extends Token {
        /**
         * @param {string} value
         * @returns {Word}
         */
        static new(value: string): Word;
        /**
         * Finds the index of the first Word(value) in a list of tokens
         * Returns -1 if none found
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @returns {Word}
         */
        assertNotInternal(): Word;
        /**
         * @returns {Word | null}
         */
        assertNotKeyword(): Word | null;
        #private;
    }
    /**
     * Symbol token represent anything non alphanumeric
     * @internal
     */
    export class SymbolToken extends Token {
        /**
         * Finds the index of the first Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * Finds the index of the last Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static findLast(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @param {?(string | string[])} value
         * @returns {SymbolToken}
         */
        assertSymbol(value: (string | string[]) | null): SymbolToken;
        #private;
    }
    /**
     * Group token can '(...)', '[...]' or '{...}' and can contain comma separated fields.
     * @internal
     */
    export class Group extends Token {
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isOpenSymbol(t: Token): boolean;
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isCloseSymbol(t: Token): boolean;
        /**
         * Returns the corresponding closing bracket, parenthesis or brace.
         * Throws an error if not a group symbol.
         * @example
         * Group.matchSymbol("(") => ")"
         * @param {string | SymbolToken} t
         * @returns {string}
         */
        static matchSymbol(t: string | SymbolToken): string;
        /**
         * Finds the index of first Group(type) in list of tokens
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string} type
         * @returns {number}
         */
        static find(ts: Token[], type: string): number;
        /**
         * @param {Site} site
         * @param {string} type - "(", "[" or "{"
         * @param {Token[][]} fields
         * @param {?SymbolToken} firstComma
         */
        constructor(site: Site, type: string, fields: Token[][], firstComma?: SymbolToken | null);
        get fields(): Token[][];
        /**
         * @param {?string} type
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(type?: string | null, nFields?: number | null): boolean;
        #private;
    }
    /**
     * Base class of literal tokens
     * @internal
     */
    export class PrimitiveLiteral extends Token {
    }
    /**
     * Signed int literal token
     * @internal
     */
    export class IntLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Fixed point number literal token
     * @internal
     */
    export class RealLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Bool literal token
     * @internal
     */
    export class BoolLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        get value(): boolean;
        #private;
    }
    /**
     * ByteArray literal token
     * @internal
     */
    export class ByteArrayLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        get bytes(): number[];
        #private;
    }
    /**
     * String literal token (utf8)
     * @internal
     */
    export class StringLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        #private;
    }
    /**
     * @internal
     * @typedef {[number, Site][]} CodeMap
     */
    /**
     * @internal
     * @typedef {Map<string, IR>} IRDefinitions
     */
    /**
     * The IR class combines a string of intermediate representation sourcecode with an optional site.
     * The site is used for mapping IR code to the original source code.
     * @internal
     */
    export class IR {
        /**
         * Wraps 'inner' IR source with some definitions (used for top-level statements and for builtins)
         * @internal
         * @param {IR} inner
         * @param {IRDefinitions} definitions - name -> definition
         * @returns {IR}
         */
        static wrapWithDefinitions(inner: IR, definitions: IRDefinitions): IR;
        /**
         * @param {string | IR[]} content
         * @param {null | Site} site
         */
        constructor(content: string | IR[], site?: null | Site);
        /**
         * @internal
         * @type {string | IR[]}
         */
        get content(): string | IR[];
        /**
         * @internal
         * @type {?Site}
         */
        get site(): Site;
        /**
         * @returns {any}
         */
        dump(): any;
        /**
         * Returns a list containing IR instances that themselves only contain strings
         * @internal
         * @returns {IR[]}
         */
        flatten(): IR[];
        /**
         * Intersperse nested IR content with a separator
         * @internal
         * @param {string} sep
         * @returns {IR}
         */
        join(sep: string): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {[string, CodeMap]}
         */
        generateSource(): [string, CodeMap];
        /**
         * @returns {string}
         */
        pretty(): string;
        /**
         * @param {string} str
         * @returns {boolean}
         */
        includes(str: string): boolean;
        /**
         * @param {RegExp} re
         * @param {string} newStr
         * @returns {IR}
         */
        replace(re: RegExp, newStr: string): IR;
        /**
         *
         * @param {RegExp} re
         * @param {(match: string) => void} callback
         */
        search(re: RegExp, callback: (match: string) => void): void;
        #private;
    }
    /**
     * @internal
     */
    export const RE_IR_PARAMETRIC_NAME: RegExp;
    /**
     * Type type parameter prefix
     * @internal
     */
    export const TTPP: "__T";
    /**
     * Func type parameter prefix
     * @internal
     */
    export const FTPP: "__F";
    /**
     * @internal
     */
    export class IRParametricName {
        /**
         * @param {string} base
         * @param {number} nTtps
         * @param {string} fn
         * @param {number} nFtps
         * @returns
         */
        static newTemplate(base: string, nTtps: number, fn?: string, nFtps?: number): IRParametricName;
        /**
         * @example
         * IRParametricName.matches("__helios__map[__T0@__T1]__fold[__F2@__F3]") => true
         * @example
         * IRParametricName.matches("__helios__int") => false
         * @example
         * IRParametricName.matches("__helios__option[__T0]__none__new") => true
         * @param {string} str
         * @returns {boolean}
         */
        static matches(str: string): boolean;
        /**
         * @param {string} name
         * @returns {boolean}
         */
        static isTemplate(name: string): boolean;
        /**
         * @example
         * IRParametricName.parse("__helios__map[__T0@__T1]__fold[__F0@__F1]").toString() => "__helios__map[__T0@__T1]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]").toString() => "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]").toString() => "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]"
         * @param {string} str
         * @param {boolean} preferType
         * @returns {IRParametricName}
         */
        static parse(str: string, preferType?: boolean): IRParametricName;
        /**
         * @param {string} base
         * @param {string[]} ttp
         * @param {string} fn
         * @param {string[]} ftp
         */
        constructor(base: string, ttp: string[], fn?: string, ftp?: string[]);
        /**
         * @type {string}
         */
        get base(): string;
        /**
         * @param {string[]} ttp
         * @param {string[]} ftp
         * @returns {IRParametricName}
         */
        toImplementation(ttp: string[], ftp?: string[]): IRParametricName;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @return {string}
         */
        toTemplate(): string;
        /**
         * @param {IR} ir
         * @returns {IR}
         */
        replaceTemplateNames(ir: IR): IR;
        #private;
    }
    /**
     * A collection of cryptography primitives are included here in order to avoid external dependencies
     *     mulberry32: random number generator
     *     base32 encoding and decoding
     *     bech32 encoding, checking, and decoding
     *     sha2_256, sha2_512, sha3 and blake2b hashing
     *     ed25519 pubkey generation, signing, and signature verification (NOTE: the current implementation is simple but slow)
     */
    export class Crypto {
        /**
         * Returns a simple random number generator
         * @internal
         * @param {number} seed
         * @returns {NumberGenerator} - a random number generator
         */
        static mulberry32(seed: number): NumberGenerator;
        /**
         * Alias for rand generator of choice
         * @internal
         * @param {number} seed
         * @returns {NumberGenerator} - the random number generator function
         */
        static rand(seed: number): NumberGenerator;
        /**
         * Rfc 4648 base32 alphabet
         * @type {string}
         */
        static get DEFAULT_BASE32_ALPHABET(): string;
        /**
         * Bech32 base32 alphabet
         * @type {string}
         */
        static get BECH32_BASE32_ALPHABET(): string;
        /**
         * Encode bytes in special base32.
         * @example
         * Crypto.encodeBase32(textToBytes("f")) => "my"
         * @example
         * Crypto.encodeBase32(textToBytes("fo")) => "mzxq"
         * @example
         * Crypto.encodeBase32(textToBytes("foo")) => "mzxw6"
         * @example
         * Crypto.encodeBase32(textToBytes("foob")) => "mzxw6yq"
         * @example
         * Crypto.encodeBase32(textToBytes("fooba")) => "mzxw6ytb"
         * @example
         * Crypto.encodeBase32(textToBytes("foobar")) => "mzxw6ytboi"
         * @param {number[]} bytes - uint8 numbers
         * @param {string} alphabet - list of chars
         * @return {string}
         */
        static encodeBase32(bytes: number[], alphabet?: string): string;
        /**
         * @internal
         * @param {number[]} bytes
         * @returns {number[]} - list of numbers between 0 and 32
         */
        static encodeBase32Bytes(bytes: number[]): number[];
        /**
         * Decode base32 string into bytes.
         * @example
         * bytesToText(Crypto.decodeBase32("my")) => "f"
         * @example
         * bytesToText(Crypto.decodeBase32("mzxq")) => "fo"
         * @example
         * bytesToText(Crypto.decodeBase32("mzxw6")) => "foo"
         * @example
         * bytesToText(Crypto.decodeBase32("mzxw6yq")) => "foob"
         * @example
         * bytesToText(Crypto.decodeBase32("mzxw6ytb")) => "fooba"
         * @example
         * bytesToText(Crypto.decodeBase32("mzxw6ytboi")) => "foobar"
         * @param {string} encoded
         * @param {string} alphabet
         * @return {number[]}
         */
        static decodeBase32(encoded: string, alphabet?: string): number[];
        /**
         * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum.
         * @internal
         * @param {string} hrp
         * @returns {number[]}
         */
        static expandBech32HumanReadablePart(hrp: string): number[];
        /**
         * Used as part of the bech32 checksum.
         * @internal
         * @param {number[]} bytes
         * @returns {number}
         */
        static calcBech32Polymod(bytes: number[]): number;
        /**
         * Generate the bech32 checksum.
         * @internal
         * @param {string} hrp
         * @param {number[]} data - numbers between 0 and 32
         * @returns {number[]} - 6 numbers between 0 and 32
         */
        static calcBech32Checksum(hrp: string, data: number[]): number[];
        /**
         * Creates a bech32 checksummed string (used to represent Cardano addresses)
         * @example
         * Crypto.encodeBech32("foo", textToBytes("foobar")) => "foo1vehk7cnpwgry9h96"
         * @example
         * Crypto.encodeBech32("addr_test", hexToBytes("70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539")) => "addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld"
         * @param {string} hrp
         * @param {number[]} data - uint8 0 - 256
         * @returns {string}
         */
        static encodeBech32(hrp: string, data: number[]): string;
        /**
         * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes
         * Throws an error if checksum is invalid.
         * @example
         * bytesToHex(Crypto.decodeBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld")[1]) => "70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539"
         * @param {string} addr
         * @returns {[string, number[]]}
         */
        static decodeBech32(addr: string): [string, number[]];
        /**
         * Verify a bech32 checksum
         * @example
         * Crypto.verifyBech32("foo1vehk7cnpwgry9h96") => true
         * @example
         * Crypto.verifyBech32("foo1vehk7cnpwgry9h97") => false
         * @example
         * Crypto.verifyBech32("a12uel5l") => true
         * @example
         * Crypto.verifyBech32("mm1crxm3i") => false
         * @example
         * Crypto.verifyBech32("A1G7SGD8") => false
         * @example
         * Crypto.verifyBech32("abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw") => true
         * @example
         * Crypto.verifyBech32("?1ezyfcl") => true
         * @example
         * Crypto.verifyBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld") => true
         * @param {string} addr
         * @returns {boolean}
         */
        static verifyBech32(addr: string): boolean;
        /**
         * Calculates sha2-256 (32bytes) hash of a list of uint8 numbers.
         * Result is also a list of uint8 number.
         * @example
         * bytesToHex(Crypto.sha2_256([0x61, 0x62, 0x63])) => "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"
         * @example
         * Crypto.sha2_256(textToBytes("Hello, World!")) => [223, 253, 96, 33, 187, 43, 213, 176, 175, 103, 98, 144, 128, 158, 195, 165, 49, 145, 221, 129, 199, 247, 10, 75, 40, 104, 138, 54, 33, 130, 152, 111]
         * @param {number[]} bytes - list of uint8 numbers
         * @returns {number[]} - list of uint8 numbers
         */
        static sha2_256(bytes: number[]): number[];
        /**
         * Calculates sha2-512 (64bytes) hash of a list of uint8 numbers.
         * Result is also a list of uint8 number.
         * @example
         * bytesToHex(Crypto.sha2_512([0x61, 0x62, 0x63])) => "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"
         * @example
         * bytesToHex(Crypto.sha2_512([])) => "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
         * @example
         * bytesToHex(Crypto.sha2_512(textToBytes("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"))) => "204a8fc6dda82f0a0ced7beb8e08a41657c16ef468b228a8279be331a703c33596fd15c13b1b07f9aa1d3bea57789ca031ad85c7a71dd70354ec631238ca3445"
         * @example
         * bytesToHex(Crypto.sha2_512(textToBytes("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstuu"))) => "23565d109ac0e2aa9fb162385178895058b28489a6bc31cb55491ed83956851ab1d4bbd46440586f5c9c4b69c9c280118cbc55c71495d258cc27cc6bb25ee720"
         * @param {number[]} bytes - list of uint8 numbers
         * @returns {number[]} - list of uint8 numbers
         */
        static sha2_512(bytes: number[]): number[];
        /**
         * Calculates sha3-256 (32bytes) hash of a list of uint8 numbers.
         * Result is also a list of uint8 number.
         * Sha3 only bit-wise operations, so 64-bit operations can easily be replicated using 2 32-bit operations instead
         * @example
         * bytesToHex(Crypto.sha3(textToBytes("abc"))) => "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532"
         * @example
         * bytesToHex(Crypto.sha3((new Array(136)).fill(1))) => "b36dc2167c4d9dda1a58b87046c8d76a6359afe3612c4de8a38857e09117b2db"
         * @example
         * bytesToHex(Crypto.sha3((new Array(135)).fill(2))) => "5bdf5d815d29a9d7161c66520efc17c2edd7898f2b99a029e8d2e4ff153407f4"
         * @example
         * bytesToHex(Crypto.sha3((new Array(134)).fill(3))) => "8e6575663dfb75a88f94a32c5b363c410278b65020734560d968aadd6896a621"
         * @example
         * bytesToHex(Crypto.sha3((new Array(137)).fill(4))) => "f10b39c3e455006aa42120b9751faa0f35c821211c9d086beb28bf3c4134c6c6"
         * @param {number[]} bytes - list of uint8 numbers
         * @returns {number[]} - list of uint8 numbers
         */
        static sha3(bytes: number[]): number[];
        /**
         * Calculates blake2b hash of a list of uint8 numbers (variable digest size).
         * Result is also a list of uint8 number.
         * Blake2b is a 64bit algorithm, so we need to be careful when replicating 64-bit operations with 2 32-bit numbers (low-word overflow must spill into high-word, and shifts must go over low/high boundary)
         * @example
         * bytesToHex(Crypto.blake2b([0, 1])) => "01cf79da4945c370c68b265ef70641aaa65eaa8f5953e3900d97724c2c5aa095"
         * @example
         * bytesToHex(Crypto.blake2b(textToBytes("abc"), 64)) => "ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d17d87c5392aab792dc252d5de4533cc9518d38aa8dbf1925ab92386edd4009923"
         * @param {number[]} bytes
         * @param {number} digestSize - at most 64
         * @returns {number[]}
         */
        static blake2b(bytes: number[], digestSize?: number): number[];
        /**
         * Don't use this directly, use hmacSha2_256 or hmacSha2_512 instead
         * @internal
         * @param {(x: number[]) => number[]} algorithm
         * @param {number} b - blockSize of algorithm
         * @param {number[]} key
         * @param {number[]} message
         * @returns {number[]}
         */
        static hmac(algorithm: (x: number[]) => number[], b: number, key: number[], message: number[]): number[];
        /**
         * @example
         * bytesToHex(Crypto.hmacSha2_256(textToBytes("key"), textToBytes("The quick brown fox jumps over the lazy dog"))) => "f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8"
         * @param {number[]} key
         * @param {number[]} message
         * @returns {number[]}
         */
        static hmacSha2_256(key: number[], message: number[]): number[];
        /**
         * @example
         * bytesToHex(Crypto.hmacSha2_512(textToBytes("key"), textToBytes("The quick brown fox jumps over the lazy dog"))) => "b42af09057bac1e2d41708e48a902e09b5ff7f12ab428a4fe86653c73dd248fb82f948a549f7b791a5b41915ee4d1ec3935357e4e2317250d0372afa2ebeeb3a"
         * @param {number[]} key
         * @param {number[]} message
         * @returns {number[]}
         */
        static hmacSha2_512(key: number[], message: number[]): number[];
        /**
         * @example
         * bytesToHex(Crypto.pbkdf2(Crypto.hmacSha2_256, textToBytes("password"), textToBytes("salt"), 1, 20)) => "120fb6cffcf8b32c43e7225256c4f837a86548c9"
         * @example
         * bytesToHex(Crypto.pbkdf2(Crypto.hmacSha2_512, textToBytes("password"), textToBytes("salt"), 2, 20)) => "e1d9c16aa681708a45f5c7c4e215ceb66e011a2e"
         * @param {(key: number[], msg: number[]) => number[]} prf
         * @param {number[]} password
         * @param {number[]} salt
         * @param {number} iters
         * @param {number} dkLength
         * @returns {number[]}
         */
        static pbkdf2(prf: (key: number[], msg: number[]) => number[], password: number[], salt: number[], iters: number, dkLength: number): number[];
        /**
         * Crypto.Ed25519 exports the following functions:
         *  * Crypto.Ed25519.derivePublicKey(privateKey)
         *  * Crypto.Ed25519.sign(message, privateKey)
         *  * Crypto.Ed25519.verify(message, signature, publicKey)
         *
         * Ported from: https://ed25519.cr.yp.to/python/ed25519.py
         * ExtendedPoint implementation from: https://github.com/paulmillr/noble-ed25519
         */
        static get Ed25519(): {
            /**
             * @param {number[]} extendedKey
             * @returns {number[]}
             */
            deriveBip32PublicKey: (extendedKey: number[]) => number[];
            /**
             * @param {number[]} privateKey
             * @returns {number[]}
             */
            derivePublicKey: (privateKey: number[]) => number[];
            /**
             * @param {number[]} message
             * @param {number[]} extendedKey
             * @returns {number[]}
             */
            signBip32: (message: number[], extendedKey: number[]) => number[];
            /**
             * @param {number[]} message
             * @param {number[]} privateKey
             * @returns {number[]}
             */
            sign: (message: number[], privateKey: number[]) => number[];
            /**
             * @param {number[]} signature
             * @param {number[]} message
             * @param {number[]} publicKey
             * @returns {boolean}
             */
            verify: (signature: number[], message: number[], publicKey: number[]) => boolean;
        };
    }
    /**
     * Standard English Bip39 dictionary consisting of 2048 words allowing wallet root keys to be formed by a phrase of 12, 15, 18, 21 or 24 of these words.
     */
    export const BIP39_DICT_EN: string[];
    /**
     * @typedef {(i: number, bytes: number[]) => void} Decoder
     */
    /**
     * Base class of any Cbor serializable data class
     * Also contains helper methods for (de)serializing data to/from Cbor
     */
    export class CborData {
        /**
         * @param {number} m - major type
         * @param {bigint} n - size parameter
         * @returns {number[]} - uint8 bytes
         */
        static encodeHead(m: number, n: bigint): number[];
        /**
         * @param {number[]} bytes - mutated to contain the rest
         * @returns {[number, bigint]} - [majorType, n]
         */
        static decodeHead(bytes: number[]): [number, bigint];
        /**
         * @param {number} m
         * @returns {number[]}
         */
        static encodeIndefHead(m: number): number[];
        /**
         * @param {number[]} bytes - cbor bytes
         * @returns {number} - majorType
         */
        static decodeIndefHead(bytes: number[]): number;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isNull(bytes: number[]): boolean;
        /**
         * @returns {number[]}
         */
        static encodeNull(): number[];
        /**
         * Throws error if not null
         * @param {number[]} bytes
         */
        static decodeNull(bytes: number[]): void;
        /**
         * @param {boolean} b
         * @returns {number[]}
         */
        static encodeBool(b: boolean): number[];
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static decodeBool(bytes: number[]): boolean;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isDefBytes(bytes: number[]): boolean;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isIndefBytes(bytes: number[]): boolean;
        /**
         * @example
         * bytesToHex(CborData.encodeBytes(hexToBytes("4d01000033222220051200120011"))) => "4e4d01000033222220051200120011"
         * @param {number[]} bytes
         * @param {boolean} splitInChunks
         * @returns {number[]} - cbor bytes
         */
        static encodeBytes(bytes: number[], splitInChunks?: boolean): number[];
        /**
         * Decodes both an indef array of bytes, and a bytearray of specified length
         * @example
         * bytesToHex(CborData.decodeBytes(hexToBytes("4e4d01000033222220051200120011"))) => "4d01000033222220051200120011"
         * @param {number[]} bytes - cborbytes, mutated to form remaining
         * @returns {number[]} - byteArray
         */
        static decodeBytes(bytes: number[]): number[];
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isUtf8(bytes: number[]): boolean;
        /**
         * Encodes a Utf8 string into Cbor bytes.
         * Strings can be split into lists with chunks of up to 64 bytes
         * to play nice with Cardano tx metadata constraints.
         * @param {string} str
         * @param {boolean} split
         * @returns {number[]}
         */
        static encodeUtf8(str: string, split?: boolean): number[];
        /**
         * @param {number[]} bytes
         * @returns {string}
         */
        static decodeUtf8Internal(bytes: number[]): string;
        /**
         * @param {number[]} bytes
         * @returns {string}
         */
        static decodeUtf8(bytes: number[]): string;
        /**
         * @param {bigint} n
         * @returns {number[]} - cbor bytes
         */
        static encodeInteger(n: bigint): number[];
        /**
         * @param {number[]} bytes
         * @returns {bigint}
         */
        static decodeInteger(bytes: number[]): bigint;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isIndefList(bytes: number[]): boolean;
        /**
         * @returns {number[]}
         */
        static encodeIndefListStart(): number[];
        /**
         * @param {CborData[] | number[][]} list
         * @returns {number[]}
         */
        static encodeListInternal(list: CborData[] | number[][]): number[];
        /**
         * @returns {number[]}
         */
        static encodeIndefListEnd(): number[];
        /**
         * @param {CborData[] | number[][]} list
         * @returns {number[]}
         */
        static encodeList(list: CborData[] | number[][]): number[];
        /**
         * @param {CborData[] | number[][]} list
         * @returns {number[]}
         */
        static encodeIndefList(list: CborData[] | number[][]): number[];
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isDefList(bytes: number[]): boolean;
        /**
         * @param {bigint} n
         * @returns {number[]}
         */
        static encodeDefListStart(n: bigint): number[];
        /**
         * @param {CborData[] | number[][]} list
         * @returns {number[]}
         */
        static encodeDefList(list: CborData[] | number[][]): number[];
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isList(bytes: number[]): boolean;
        /**
         * @param {number[]} bytes
         * @param {Decoder} itemDecoder
         */
        static decodeList(bytes: number[], itemDecoder: Decoder): void;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isTuple(bytes: number[]): boolean;
        /**
         * @param {number[][]} tuple
         * @returns {number[]}
         */
        static encodeTuple(tuple: number[][]): number[];
        /**
         * @param {number[]} bytes
         * @param {Decoder} tupleDecoder
         * @returns {number} - returns the size of the tuple
         */
        static decodeTuple(bytes: number[], tupleDecoder: Decoder): number;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isMap(bytes: number[]): boolean;
        /**
         * @param {[CborData | number[], CborData | number[]][]} pairList
         * @returns {number[]}
         */
        static encodeMapInternal(pairList: [CborData | number[], CborData | number[]][]): number[];
        /**
         * A decode map method doesn't exist because it specific for the requested type
         * @param {[CborData | number[], CborData | number[]][]} pairList
         * @returns {number[]}
         */
        static encodeMap(pairList: [CborData | number[], CborData | number[]][]): number[];
        /**
         * @param {number[]} bytes
         * @param {Decoder} pairDecoder
         */
        static decodeMap(bytes: number[], pairDecoder: Decoder): void;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isObject(bytes: number[]): boolean;
        /**
         * @param {Map<number, CborData | number[]>} object
         * @returns {number[]}
         */
        static encodeObject(object: Map<number, CborData | number[]>): number[];
        /**
         * @param {number[]} bytes
         * @param {Decoder} fieldDecoder
         * @returns {Set<number>}
         */
        static decodeObject(bytes: number[], fieldDecoder: Decoder): Set<number>;
        /**
         * Unrelated to constructor
         * @param {bigint} tag
         * @returns {number[]}
         */
        static encodeTag(tag: bigint): number[];
        /**
         * @param {number[]} bytes
         * @returns {bigint}
         */
        static decodeTag(bytes: number[]): bigint;
        /**
         * @param {number[]} bytes
         * @returns {boolean}
         */
        static isConstr(bytes: number[]): boolean;
        /**
         * Encode a constructor tag of a ConstrData type
         * @param {number} tag
         * @returns {number[]}
         */
        static encodeConstrTag(tag: number): number[];
        /**
         * @param {number} tag
         * @param {CborData[] | number[][]} fields
         * @returns {number[]}
         */
        static encodeConstr(tag: number, fields: CborData[] | number[][]): number[];
        /**
         * @param {number[]} bytes
         * @returns {number}
         */
        static decodeConstrTag(bytes: number[]): number;
        /**
         * Returns the tag
         * @param {number[]} bytes
         * @param {Decoder} fieldDecoder
         * @returns {number}
         */
        static decodeConstr(bytes: number[], fieldDecoder: Decoder): number;
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }
    /**
     * Base class for Plutus-core data classes (not the same as Plutus-core value classes!)
     */
    export class UplcData extends CborData {
        /**
         * @param {hexstring | number[]} bytes
         * @returns {UplcData}
         */
        static fromCbor(bytes: hexstring | number[]): UplcData;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Estimate of memory usage during validation
         * @type {number}
         */
        get memSize(): number;
        /**
         * Compares the schema jsons
         * @param {UplcData} other
         * @returns {boolean}
         */
        isSame(other: UplcData): boolean;
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @type {number}
         */
        get index(): number;
        /**
         * @type {UplcData[]}
         */
        get fields(): UplcData[];
        /**
         * @type {UplcData[]}
         */
        get list(): UplcData[];
        /**
         * @type {[UplcData, UplcData][]}
         */
        get map(): [UplcData, UplcData][];
        /**
         * @internal
         * @returns {IR}
         */
        toIR(): IR;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Plutus-core int data class
     */
    export class IntData extends UplcData {
        /**
         * Calculate the mem size of a integer (without the DATA_NODE overhead)
         * @param {bigint} value
         * @returns {number}
         */
        static memSizeInternal(value: bigint): number;
        /**
         * @param {number[]} bytes
         * @returns {IntData}
         */
        static fromCbor(bytes: number[]): IntData;
        /**
         * @param {bigint} value
         */
        constructor(value: bigint);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        #private;
    }
    /**
     * Plutus-core bytearray data class.
     * Wraps a regular list of uint8 numbers (so not Uint8Array)
     */
    export class ByteArrayData extends UplcData {
        /**
         * Applies utf-8 encoding
         * @param {string} s
         * @returns {ByteArrayData}
         */
        static fromString(s: string): ByteArrayData;
        /**
         * Calculates the mem size of a byte array without the DATA_NODE overhead.
         * @param {number[]} bytes
         * @returns {number}
         */
        static memSizeInternal(bytes: number[]): number;
        /**
         * @param {number[]} bytes
         * @returns {ByteArrayData}
         */
        static fromCbor(bytes: number[]): ByteArrayData;
        /**
         * Bytearray comparison, which can be used for sorting bytearrays
         * @example
         * ByteArrayData.comp(hexToBytes("0101010101010101010101010101010101010101010101010101010101010101"), hexToBytes("0202020202020202020202020202020202020202020202020202020202020202")) => -1
         * @param {number[]} a
         * @param {number[]} b
         * @returns {number} - 0 -> equals, 1 -> gt, -1 -> lt
         */
        static comp(a: number[], b: number[]): number;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @returns {hexstring}
         */
        toHex(): hexstring;
        #private;
    }
    /**
     * Plutus-core list data class
     */
    export class ListData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ListData}
         */
        static fromCbor(bytes: number[]): ListData;
        /**
         * @param {UplcData[]} items
         */
        constructor(items: UplcData[]);
        #private;
    }
    /**
     * Plutus-core map data class
     */
    export class MapData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {MapData}
         */
        static fromCbor(bytes: number[]): MapData;
        /**
         * @param {[UplcData, UplcData][]} pairs
         */
        constructor(pairs: [UplcData, UplcData][]);
        #private;
    }
    /**
     * Plutus-core constructed data class
     */
    export class ConstrData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ConstrData}
         */
        static fromCbor(bytes: number[]): ConstrData;
        /**
         * @param {number} index
         * @param {UplcData[]} fields
         */
        constructor(index: number, fields: UplcData[]);
        #private;
    }
    /**
     * Base-type of all data-types that exist both on- and off-chain, and map directly to Helios instances.
     * @deprecated
     */
    export class HeliosData extends CborData {
        /**
         * Most HeliosData classes are builtin
         * @returns {boolean}
         */
        static isBuiltin(): boolean;
        /**
         * Name begins with underscore so it can never conflict with structure field names.
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Deprecated
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   new(...args: any[]): T
     *   fromUplcCbor: (bytes: (string | number[])) => T
     *   fromUplcData: (data: UplcData) => T
     *   isBuiltin(): boolean
     * }} HeliosDataClass
     */
    /**
     * @deprecated
     * @typedef {number | bigint} HIntProps
     */
    /**
     * Helios Int type
     * @deprecated
     */
    export class HInt extends HeliosData {
        /**
         * @internal
         * @param {HIntProps} rawValue
         * @returns {bigint}
         */
        static cleanConstructorArg(rawValue: HIntProps): bigint;
        /**
         * @param {HInt | HIntProps} props
         * @returns {HInt}
         */
        static fromProps(props: HInt | HIntProps): HInt;
        /**
         * @param {UplcData} data
         * @returns {HInt}
         */
        static fromUplcData(data: UplcData): HInt;
        /**
         * @param {string | number[]} bytes
         * @returns {HInt}
         */
        static fromUplcCbor(bytes: string | number[]): HInt;
        /**
         * @param {number[]} bytes
         * @returns {HInt}
         */
        static fromCbor(bytes: number[]): HInt;
        /**
         * @param {HIntProps} rawValue
         */
        constructor(rawValue: HIntProps);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        eq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        neq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        ge(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        gt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        le(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        lt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        add(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt | HIntProps} other
         * @returns {HInt}
         */
        sub(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        mul(other: HInt | HIntProps): HInt;
        #private;
    }
    /**
     * @internal
     * @typedef {number | bigint | string | Date} TimeProps
     */
    /**
     * Milliseconds since 1 jan 1970
     * @internal
     */
    export class Time extends HInt {
        /**
        * @internal
        * @param {TimeProps} props
        * @returns {bigint}
        */
        static cleanConstructorArg(props: TimeProps): bigint;
        /**
         * @param {Time | TimeProps} props
         * @returns {Time}
         */
        static fromProps(props: Time | TimeProps): Time;
        /**
         * @param {TimeProps} props
         */
        constructor(props: TimeProps);
    }
    /**
     * @internal
     * @typedef {HIntProps} DurationProps
     */
    /**
     * Difference between two time values in milliseconds.
     * @internal
     */
    export class Duration extends HInt {
    }
    /**
     * @internal
     * @typedef {boolean | string} BoolProps
     */
    /**
     * Helios Bool type
     * @internal
     */
    export class Bool extends HeliosData {
        /**
         * @internal
         * @param {BoolProps} props
         * @returns {boolean}
         */
        static cleanConstructorArg(props: BoolProps): boolean;
        /**
         * @param {Bool | BoolProps} props
         * @returns {Bool}
         */
        static fromProps(props: Bool | BoolProps): Bool;
        /**
         * @param {UplcData} data
         * @returns {Bool}
         */
        static fromUplcData(data: UplcData): Bool;
        /**
         * @param {string | number[]} bytes
         * @returns {Bool}
         */
        static fromUplcCbor(bytes: string | number[]): Bool;
        /**
         * @param {BoolProps} props
         */
        constructor(props: BoolProps);
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        #private;
    }
    /**
     * @internal
     * @typedef {string} HStringProps
     */
    /**
     * Helios String type.
     * Can't be named 'String' because that would interfere with the javascript 'String'-type
     * @internal
     */
    export class HString extends HeliosData {
        /**
         * @param {HString | HStringProps} props
         * @returns {HString}
         */
        static fromProps(props: HString | HStringProps): HString;
        /**
         * @param {UplcData} data
         * @returns {HString}
         */
        static fromUplcData(data: UplcData): HString;
        /**
         * @param {string | number[]} bytes
         * @returns {HString}
         */
        static fromUplcCbor(bytes: string | number[]): HString;
        /**
         * @param {HStringProps} props
         */
        constructor(props: HStringProps);
        /**
         * @type {string}
         */
        get string(): string;
        #private;
    }
    /**
     * @deprecated
     * @typedef {hexstring | number[]} ByteArrayProps
     */
    /**
     * Helios ByteArray type
     * @deprecated
     */
    export class ByteArray extends HeliosData {
        /**
         * @internal
         * @param {ByteArrayProps} props
         */
        static cleanConstructorArg(props: ByteArrayProps): number[];
        /**
         * @param {ByteArray | ByteArrayProps} props
         * @returns {ByteArray}
         */
        static fromProps(props: ByteArray | ByteArrayProps): ByteArray;
        /**
         * @param {UplcData} data
         * @returns {ByteArray}
         */
        static fromUplcData(data: UplcData): ByteArray;
        /**
         * @param {string | number[]} bytes
         * @returns {ByteArray}
         */
        static fromUplcCbor(bytes: string | number[]): ByteArray;
        /**
         * @param {number[]} bytes
         * @returns {ByteArray}
         */
        static fromCbor(bytes: number[]): ByteArray;
        /**
         * @param {ByteArrayProps} props
         */
        constructor(props: ByteArrayProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {hexstring}
         */
        get hex(): hexstring;
        /**
         * @param {ByteArray | ByteArrayProps} other
         * @returns {boolean}
         */
        eq(other: ByteArray | ByteArrayProps): boolean;
        #private;
    }
    /**
     * @typedef {hexstring | number[]} HashProps
     */
    /**
     * Base class of all hash-types
     */
    export class Hash extends HeliosData {
        /**
         * @internal
         * @param {HashProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: HashProps): number[];
        /**
         * @param {Hash | HashProps} props
         * @returns {Hash}
         */
        static fromProps(props: Hash | HashProps): Hash;
        /**
         * Used internally for metadataHash and scriptDataHash
         * @param {number[]} bytes
         * @returns {Hash}
         */
        static fromCbor(bytes: number[]): Hash;
        /**
         * Might be needed for internal use
         * @param {hexstring} str
         * @returns {Hash}
         */
        static fromHex(str: hexstring): Hash;
        /**
         * @param {Hash} a
         * @param {Hash} b
         * @returns {number}
         */
        static compare(a: Hash, b: Hash): number;
        /**
         * @param {HashProps} props
         */
        constructor(props: HashProps);
        /**
         * @readonly
         * @type {number[]}
         */
        readonly bytes: number[];
        /**
         * @returns {hexstring}
         */
        get hex(): hexstring;
        /**
         * @internal
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {Hash} other
         * @returns {boolean}
         */
        eq(other: Hash): boolean;
    }
    /**
     * @typedef {HashProps} DatumHashProps
     */
    export class DatumHash extends Hash {
        /**
         * @param {UplcData} data
         * @returns {DatumHash}
         */
        static fromUplcData(data: UplcData): DatumHash;
        /**
         * @param {string | number[]} bytes
         * @returns {DatumHash}
         */
        static fromUplcCbor(bytes: string | number[]): DatumHash;
        /**
         * @param {string} str
         * @returns {DatumHash}
         */
        static fromHex(str: string): DatumHash;
    }
    /**
     * @typedef {hexstring | number[]} PubKeyProps
     */
    export class PubKey extends HeliosData {
        /**
         * @param {PubKey | PubKeyProps} props
         * @returns {PubKey}
         */
        static fromProps(props: PubKey | PubKeyProps): PubKey;
        /**
         * @returns {PubKey}
         */
        static dummy(): PubKey;
        /**
         * @param {UplcData} data
         * @returns {PubKey}
         */
        static fromUplcData(data: UplcData): PubKey;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKey}
         */
        static fromUplcCbor(bytes: string | number[]): PubKey;
        /**
         * @param {number[]} bytes
         * @returns {PubKey}
         */
        static fromCbor(bytes: number[]): PubKey;
        /**
         * @param {PubKeyProps} props
         */
        constructor(props: PubKeyProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {hexstring}
         */
        get hex(): hexstring;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @type {StakeKeyHash}
         */
        get stakeKeyHash(): StakeKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * @returns {string}
         */
        dump(): string;
        #private;
    }
    /**
     * @typedef {HashProps} PubKeyHashProps
     */
    export class PubKeyHash extends Hash {
        /**
         * @param {UplcData} data
         * @returns {PubKeyHash}
         */
        static fromUplcData(data: UplcData): PubKeyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKeyHash}
         */
        static fromUplcCbor(bytes: string | number[]): PubKeyHash;
        /**
         * @param {string} str
         * @returns {PubKeyHash}
         */
        static fromHex(str: string): PubKeyHash;
    }
    /**
     * @internal
     * @typedef {HashProps} ScriptHashProps
     */
    /**
     * Base class of MintingPolicyHash, ValidatorHash and StakingValidatorHash
     */
    export class ScriptHash extends Hash {
    }
    /**
     * @typedef {HashProps} MintingPolicyHashProps
     */
    export class MintingPolicyHash extends ScriptHash {
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} props
         * @returns {MintingPolicyHash}
         */
        static fromProps(props: MintingPolicyHash | MintingPolicyHashProps): MintingPolicyHash;
        /**
         * @param {number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromCbor(bytes: number[]): MintingPolicyHash;
        /**
         * @param {UplcData} data
         * @returns {MintingPolicyHash}
         */
        static fromUplcData(data: UplcData): MintingPolicyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromUplcCbor(bytes: string | number[]): MintingPolicyHash;
        /**
         * @param {string} str
         * @returns {MintingPolicyHash}
         */
        static fromHex(str: string): MintingPolicyHash;
        /**
         * Encodes as bech32 string using 'asset' as human readable part
         * @returns {string}
         */
        toBech32(): string;
    }
    /**
     * @typedef {HashProps} StakeKeyHashProps
     */
    export class StakeKeyHash extends Hash {
        /**
         * @param {UplcData} data
         * @returns {StakeKeyHash}
         */
        static fromUplcData(data: UplcData): StakeKeyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {StakeKeyHash}
         */
        static fromUplcCbor(bytes: string | number[]): StakeKeyHash;
        /**
         * @param {string} str
         * @returns {StakeKeyHash}
         */
        static fromHex(str: string): StakeKeyHash;
    }
    /**
     * @typedef {HashProps} StakingValidatorHashProps
     */
    export class StakingValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {StakingValidatorHash}
         */
        static fromUplcData(data: UplcData): StakingValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {StakingValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): StakingValidatorHash;
        /**
         * @param {string} str
         * @returns {StakingValidatorHash}
         */
        static fromHex(str: string): StakingValidatorHash;
    }
    /**
     * @typedef {HashProps} ValidatorHashProps
     */
    export class ValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {ValidatorHash}
         */
        static fromUplcData(data: UplcData): ValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {ValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): ValidatorHash;
        /**
         * @param {string} str
         * @returns {ValidatorHash}
         */
        static fromHex(str: string): ValidatorHash;
    }
    /**
     * @typedef {HashProps} TxIdProps
     */
    /**
     * Hash of a transaction
     */
    export class TxId extends Hash {
        /**
         * @param {UplcData} data
         * @returns {TxId}
         */
        static fromUplcData(data: UplcData): TxId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxId}
         */
        static fromUplcCbor(bytes: string | number[]): TxId;
        /**
         * Filled with 255 so that the internal show() function has max execution budget cost
         * @param {number} fill
         * @returns {TxId}
         */
        static dummy(fill?: number): TxId;
    }
    /**
     * @typedef {string | [
     * 	 TxId | TxIdProps,
     *   HInt | HIntProps
     * ] | {
     *   txId: TxId | TxIdProps
     *   utxoId: HInt | HIntProps
     * }} TxOutputIdProps
     */
    /**
     * Id of a Utxo
     */
    export class TxOutputId extends HeliosData {
        /**
         * @param  {TxOutputIdProps} props
         * @returns {[TxId | TxIdProps, HInt | HIntProps]}
         */
        static cleanConstructorArgs(props: TxOutputIdProps): [TxId | TxIdProps, HInt | HIntProps];
        /**
         * @param {TxOutputId | TxOutputIdProps} props
         * @returns {TxOutputId}
         */
        static fromProps(props: TxOutputId | TxOutputIdProps): TxOutputId;
        /**
         * @param {UplcData} data
         * @returns {TxOutputId}
         */
        static fromUplcData(data: UplcData): TxOutputId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxOutputId}
         */
        static fromUplcCbor(bytes: string | number[]): TxOutputId;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxOutputId}
         */
        static fromCbor(rawBytes: string | number[]): TxOutputId;
        /**
         *
         * @param {TxOutputId} a
         * @param {TxOutputId} b
         * @returns {number}
         */
        static comp(a: TxOutputId, b: TxOutputId): number;
        /**
         * @param {TxOutputIdProps} props
         */
        constructor(props: TxOutputIdProps);
        /**
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         * @param {TxOutputId} other
         * @returns {boolean}
         */
        eq(other: TxOutputId): boolean;
        /**
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        #private;
    }
    /**
     * A valid bech32 string
     * @typedef {string & {}} bech32string
     */
    /**
     * @typedef {bech32string | hexstring | number[]} AddressProps
     */
    /**
     * Wrapper for Cardano address bytes. An `Address` consists of three parts internally:
     *   * Header (1 byte, see [CIP 19](https://cips.cardano.org/cips/cip19/))
     *   * Witness hash (28 bytes that represent the `PubKeyHash` or `ValidatorHash`)
     *   * Optional staking credential (0 or 28 bytes)
     */
    export class Address extends HeliosData {
        /**
         * @internal
         * @param {AddressProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: AddressProps): number[];
        /**
         * @param {Address | AddressProps} props
         * @returns {Address}
         */
        static fromProps(props: Address | AddressProps): Address;
        /**
         * @param {number[]} bytes
         * @returns {Address}
         */
        static fromCbor(bytes: number[]): Address;
        /**
         * @param {bech32string} str
         * @returns {Address}
         */
        static fromBech32(str: bech32string): Address;
        /**
         * Doesn't check validity
         * @param {hexstring} hex
         * @returns {Address}
         */
        static fromHex(hex: hexstring): Address;
        /**
         * @param {PubKeyHash | ValidatorHash} hash
         * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromHashes(hash: PubKeyHash | ValidatorHash, stakingHash?: (StakeKeyHash | StakingValidatorHash) | null, isTestnet?: boolean): Address;
        /**
         * Simple payment address without a staking part
         * @param {PubKeyHash} hash
         * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromPubKeyHash(hash: PubKeyHash, stakingHash?: (StakeKeyHash | StakingValidatorHash) | null, isTestnet?: boolean): Address;
        /**
         * Simple script address without a staking part
         * Only relevant for validator scripts
         * @param {ValidatorHash} hash
         * @param {?(StakeKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromValidatorHash(hash: ValidatorHash, stakingHash?: (StakeKeyHash | StakingValidatorHash) | null, isTestnet?: boolean): Address;
        /**
         * @param {Address} address
         * @returns {boolean}
         */
        static isForTestnet(address: Address): boolean;
        /**
         * @param {UplcData} data
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcData(data: UplcData, isTestnet?: boolean): Address;
        /**
         * @param {string | number[]} bytes
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcCbor(bytes: string | number[], isTestnet?: boolean): Address;
        /**
         * Used to sort txbody withdrawals
         * @param {Address} a
         * @param {Address} b
         * @return {number}
         */
        static compStakingHashes(a: Address, b: Address): number;
        /**
         * @param {number[] | string} bytesOrBech32String
         */
        constructor(bytesOrBech32String: number[] | string);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Returns the raw Address bytes as a hex encoded string
         * @returns {hexstring}
         */
        toHex(): hexstring;
        /**
         * @returns {bech32string}
         */
        toBech32(): bech32string;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         *
         * @private
         * @returns {ConstrData}
         */
        private toCredentialData;
        /**
         * @returns {ConstrData}
         */
        toStakingData(): ConstrData;
        /**
         * @type {null | PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @type {null | ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * @type {null | StakeKeyHash | StakingValidatorHash}
         */
        get stakingHash(): StakeKeyHash | StakingValidatorHash;
        #private;
    }
    /**
     * @typedef {string | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   ByteArray | ByteArrayProps
     * ] | {
     *   mph: MintingPolicyHash | MintingPolicyHashProps,
     *   tokenName: ByteArray | ByteArrayProps
     * }} AssetClassProps
     */
    export class AssetClass extends HeliosData {
        /**
         * @param {AssetClassProps} props
         * @returns {[MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps]}
         */
        static cleanConstructorArgs(props: AssetClassProps): [MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps];
        /**
         * @param {AssetClass | AssetClassProps} props
         * @returns {AssetClass}
         */
        static fromProps(props: AssetClass | AssetClassProps): AssetClass;
        /**
         *
         * @param {UplcData} data
         * @returns {AssetClass}
         */
        static fromUplcData(data: UplcData): AssetClass;
        /**
         * @param {number[]} bytes
         */
        static fromCbor(bytes: number[]): AssetClass;
        /**
         * @param {string | number[]} bytes
         * @returns {AssetClass}
         */
        static fromUplcCbor(bytes: string | number[]): AssetClass;
        /**
         * @type {AssetClass}
         */
        static get ADA(): AssetClass;
        /**
         * @param {AssetClassProps} props
         */
        constructor(props: AssetClassProps);
        /**
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * @type {ByteArray}
         */
        get tokenName(): ByteArray;
        /**
         * Used when generating script contexts for running programs
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        /**
         * Cip14 fingerprint
         * This involves a hash, so you can't use a fingerprint to calculate the underlying policy/tokenName.
         * @returns {string}
         */
        toFingerprint(): string;
        #private;
    }
    /**
     * @typedef {[
     *   AssetClass | AssetClassProps,
     *   HInt | HIntProps
     * ][] | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   [
     *     ByteArray | ByteArrayProps,
     *     HInt | HIntProps
     *   ][]
     * ][]} AssetsProps
     */
    /**
     * Collection of non-lovelace assets
     */
    export class Assets extends CborData {
        /**
         * @param {Assets | AssetsProps} props
         * @returns {Assets}
         */
        static fromProps(props: Assets | AssetsProps): Assets;
        /**
         * @param {number[]} bytes
         * @returns {Assets}
         */
        static fromCbor(bytes: number[]): Assets;
        /**
         * Also normalizes the assets
         * @param {AssetsProps} props
         */
        constructor(props?: AssetsProps);
        /**
         * @type {MintingPolicyHash[]}
         */
        get mintingPolicies(): MintingPolicyHash[];
        /**
         * @type {number}
         */
        get nTokenTypes(): number;
        /**
         * Returns empty if mph not found
         * @param {MintingPolicyHash} mph
         * @returns {[ByteArray, HInt][]}
         */
        getTokens(mph: MintingPolicyHash): [ByteArray, HInt][];
        /**
         * @returns {boolean}
         */
        isZero(): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {boolean}
         */
        has(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {bigint}
         */
        get(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): bigint;
        /**
         * Mutates 'this'
         */
        removeZeroes(): void;
        /**
         * Removes zeros and merges duplicates
         * In-place algorithm
         * Keeps the same order as much as possible
         */
        normalize(): void;
        /**
         * Mutates 'this'
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         */
        addComponent(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): void;
        /**
         * @param {Assets} other
         * @param {(a: bigint, b: bigint) => bigint} op
         * @returns {Assets}
         */
        applyBinOp(other: Assets, op: (a: bigint, b: bigint) => bigint): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        add(other: Assets): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        sub(other: Assets): Assets;
        /**
         * @param {HInt | HIntProps} scalar
         * @returns {Assets}
         */
        mul(scalar: HInt | HIntProps): Assets;
        /**
         * Mutates 'this'
         * Throws error if mph is already contained in 'this'
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @returns {ByteArray[]}
         */
        getTokenNames(mph: MintingPolicyHash | MintingPolicyHashProps): ByteArray[];
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        eq(other: Assets): boolean;
        /**
         * Strict gt, if other contains assets this one doesn't contain => return false
         * @param {Assets} other
         * @returns {boolean}
         */
        gt(other: Assets): boolean;
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        ge(other: Assets): boolean;
        /**
         * @returns {boolean}
         */
        allPositive(): boolean;
        /**
         * Throws an error if any contained quantity <= 0n
         */
        assertAllPositive(): void;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when generating script contexts for running programs
         * @returns {MapData}
         */
        _toUplcData(): MapData;
        /**
         * Makes sure minting policies are in correct order
         * Mutates 'this'
         * Order of tokens per mintingPolicyHash isn't changed
         */
        sort(): void;
        assertSorted(): void;
        #private;
    }
    /**
     * @typedef {HInt | HIntProps | [
     *   HInt | HIntProps,
     *   Assets | AssetsProps
     * ] | {
     *   lovelace: HInt| HIntProps,
     *   assets?:   Assets | AssetsProps
     * }} ValueProps
     */
    export class Value extends HeliosData {
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} maybeAssets
         * @returns {[HInt | HIntProps, Assets | AssetsProps]}
         */
        static cleanConstructorArgs(props: ValueProps, maybeAssets: null | Assets | AssetsProps): [HInt | HIntProps, Assets | AssetsProps];
        /**
         * @param {ValueProps | Value} props
         * @returns {Value}
         */
        static fromProps(props: ValueProps | Value): Value;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         * @returns {Value}
         */
        static asset(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): Value;
        /**
         * @param {number[]} bytes
         * @returns {Value}
         */
        static fromCbor(bytes: number[]): Value;
        /**
         * @param {Value[]} values
         * @returns {Value}
         */
        static sum(values: Value[]): Value;
        /**
         * Useful when deserializing inline datums
         * @param {UplcData} data
         * @returns {Value}
         */
        static fromUplcData(data: UplcData): Value;
        /**
         * @param {string | number[]} bytes
         * @returns {Value}
         */
        static fromUplcCbor(bytes: string | number[]): Value;
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} assets
         */
        constructor(props?: ValueProps, assets?: null | Assets | AssetsProps);
        /**
         * @type {Assets}
         */
        get assets(): Assets;
        /**
         * @type {bigint}
         */
        get lovelace(): bigint;
        /**
         * Setter for lovelace
         * Note: mutation is handy when balancing transactions
         * @param {HInt | HIntProps} lovelace
         */
        setLovelace(lovelace: HInt | HIntProps): void;
        /**
         * @param {Value} other
         * @returns {Value}
         */
        add(other: Value): Value;
        /**
         * @param {Value} other
         * @returns {Value}
         */
        sub(other: Value): Value;
        /**
         * @param {HInt | HIntProps} scalar
         * @returns {Value}
         */
        mul(scalar: HInt | HIntProps): Value;
        /**
         * @param {Value} other
         * @returns {boolean}
         */
        eq(other: Value): boolean;
        /**
         * Strictly greater than. Returns false if any asset is missing
         * @param {Value} other
         * @returns {boolean}
         */
        gt(other: Value): boolean;
        /**
         * Strictly >=
         * @param {Value} other
         * @returns {boolean}
         */
        ge(other: Value): boolean;
        /**
         * Throws an error if any contained quantity is negative
         * Used when building transactions because transactions can't contain negative values
         * @returns {Value} - returns this
         */
        assertAllPositive(): Value;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when building script context
         * @param {boolean} isInScriptContext
         * @returns {MapData}
         */
        _toUplcData(isInScriptContext?: boolean): MapData;
        #private;
    }
    /**
     * @typedef {Object} Cost
     * @property {bigint} mem
     * @property {bigint} cpu
     */
    /**
     * @typedef {() => bigint} LiveSlotGetter
     */
    /**
     * NetworkParams contains all protocol parameters. These are needed to do correct, up-to-date, cost calculations.
     */
    export class NetworkParams {
        /**
         * @param {Object} raw
         * @param {null | LiveSlotGetter} liveSlotGetter
         */
        constructor(raw: any, liveSlotGetter?: null | LiveSlotGetter);
        /**
         * @type {Object}
         */
        get raw(): any;
        /**
         * @type {null | bigint}
         */
        get liveSlot(): bigint;
        /**
         * @internal
         * @type {Object}
         */
        get costModel(): any;
        /**
         * @internal
         * @param {string} key
         * @returns {number}
         */
        getCostModelParameter(key: string): number;
        /**
         * @internal
         * @param {string} name
         * @returns {Cost}
         */
        getTermCost(name: string): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreStartupCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreVariableCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreLambdaCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreDelayCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreCallCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreConstCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreForceCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreBuiltinCost(): Cost;
        /**
         * @internal
         * @type {[number, number]} - a + b*size
         */
        get txFeeParams(): [number, number];
        /**
         * @internal
         * @type {[number, number]} - [memFee, cpuFee]
         */
        get exFeeParams(): [number, number];
        /**
         * @internal
         * @type {number[]}
         */
        get sortedCostParams(): number[];
        /**
         * @internal
         * @type {number}
         */
        get lovelacePerUTXOByte(): number;
        /**
         * @internal
         * @type {number}
         */
        get minCollateralPct(): number;
        /**
         * @internal
         * @type {number}
         */
        get maxCollateralInputs(): number;
        /**
         * @internal
         * @type {[number, number]} - [mem, cpu]
         */
        get maxTxExecutionBudget(): [number, number];
        /**
         * @internal
         * @type {number}
         */
        get maxTxSize(): number;
        /**
         * @internal
         * @type {bigint}
         */
        get maxTxFee(): bigint;
        /**
         * Use the latest slot in networkParameters to determine time.
         * @internal
         * @param {bigint} slot
         * @returns {bigint}
         */
        slotToTime(slot: bigint): bigint;
        /**
         * Use the latest slot in network parameters to determine slot.
         * @internal
         * @param {bigint} time - milliseconds since 1970
         * @returns {bigint}
         */
        timeToSlot(time: bigint): bigint;
        #private;
    }
    /**
     * Each builtin has an associated CostModel.
     * The CostModel calculates the execution cost of a builtin, depending on the byte-size of the inputs.
     * @internal
     */
    export class CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName
         * @returns {CostModel}
         */
        static fromParams(params: NetworkParams, baseName: string): CostModel;
        /**
         * @param {number[]} args
         * @returns {bigint}
         */
        calc(args: number[]): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
    }
    /**
     * A simple constant cost, independent of arg size.
     * @internal
     */
    export class ConstCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ConstCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ConstCost;
        /**
         * @param {bigint} constant
         */
        constructor(constant: bigint);
        #private;
    }
    /**
     * cost = a + b*size(arg)
     * @internal
     */
    export class LinearCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {[bigint, bigint]}
         */
        static getParams(params: NetworkParams, baseName: string): [bigint, bigint];
        /**
         * a + b*SizeFn(x, y)
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         */
        constructor(a: bigint, b: bigint);
        /**
         * @param  {number} size
         * @returns {bigint}
         */
        calcInternal(size: number): bigint;
        #private;
    }
    /**
     * cost = a + b*size(args[i])
     * @internal
     */
    export class ArgSizeCost extends LinearCost {
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} i - index of the arg
         */
        constructor(a: bigint, b: bigint, i: number);
        #private;
    }
    /**
     * cost = a + b*size(arg0)
     * @internal
     */
    export class Arg0SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg0SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg0SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg1)
     * @internal
     */
    export class Arg1SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg1SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg1SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg2)
     * @internal
     */
    export class Arg2SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg2SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg2SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*min(args)
     * @internal
     */
    export class MinArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(args)
     * @internal
     */
    export class MaxArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*sum(sizes(args))
     * @internal
     */
    export class SumArgSizesCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(size(arg0)-size(arg1), min)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiffCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiffCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiffCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} min
         */
        constructor(a: bigint, b: bigint, min: number);
        #private;
    }
    /**
     * cost = (size(arg0) > size(arg1)) ? constant : a + b*size(arg0)*size(arg1)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeProdCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * cost = (size(arg0) != size(arg1)) ? constant : a + b*size(arg0)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiagCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiagCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiagCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * @internal
     * @typedef CostModelClass
     * @property {(params: NetworkParams, baseName: string) => CostModel} fromParams
     */
    /**
     * Cost-model configuration of UplcBuiltin.
     * Also specifies the number of times a builtin must be 'forced' before being callable.
     * @internal
     */
    export class UplcBuiltinConfig {
        /**
         * @param {string} name
         * @param {number} forceCount - number of type parameters of a Plutus-core builtin function (0, 1 or 2)
         * @param {number} nArgs
         * @param {boolean} allowAny
         * @param {CostModelClass} memCostModelClass
         * @param {CostModelClass} cpuCostModelClass
         */
        constructor(name: string, forceCount: number, nArgs: number, allowAny: boolean, memCostModelClass: CostModelClass, cpuCostModelClass: CostModelClass);
        get name(): string;
        get forceCount(): number;
        get nArgs(): number;
        get allowAny(): boolean;
        /**
         * @param {NetworkParams} params
         * @returns {[CostModel, CostModel]}
         */
        instantiateCostModels(params: NetworkParams): [CostModel, CostModel];
        /**
         * @param {NetworkParams} params
         * @param {number[]} argSizes
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, argSizes: number[]): Cost;
        /**
         * @param {NetworkParams} params
         */
        dumpCostModel(params: NetworkParams): void;
        #private;
    }
    /**
     * A list of all PlutusScript builins, with associated costmodels (actual costmodel parameters are loaded from NetworkParams during runtime)
     * @internal
     * @type {UplcBuiltinConfig[]}
     */
    export const UPLC_BUILTINS: UplcBuiltinConfig[];
    /**
     * @internal
     */
    export const UPLC_MACROS_OFFSET: number;
    /**
     * Index to helios-specific macro mapping
     * @internal
     */
    export const UPLC_MACROS: string[];
    /**
     * A Helios/Uplc Program can have different purposes
     * @typedef {"testing" | "minting" | "spending" | "staking" | "linking" | "module" | "unknown"} ScriptPurpose
     */
    /**
     * a UplcValue is passed around by Plutus-core expressions.
     */
    export class UplcValue {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Return a copy of the UplcValue at a different Site.
         * @internal
         * @param {Site} newSite
         * @returns {UplcValue}
         */
        copy(newSite: Site): UplcValue;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Size in words (8 bytes, 64 bits) occupied in target node
         * @internal
         * @type {number}
         */
        get memSize(): number;
        /**
         * Throws an error because most values can't be called (overridden by UplcAnon)
         * @internal
         * @param {UplcRte | UplcStack} rte
         * @param {Site} site
         * @param {UplcValue} value
         * @returns {Promise<UplcValue>}
         */
        call(rte: UplcRte | UplcStack, site: Site, value: UplcValue): Promise<UplcValue>;
        /**
         * @internal
         * @param {UplcRte | UplcStack} rte
         * @returns {Promise<UplcValue>}
         */
        eval(rte: UplcRte | UplcStack): Promise<UplcValue>;
        /**
         * @returns {boolean}
         */
        isAny(): boolean;
        /**
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get string(): string;
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        /**
         * Distinguishes a pair from a mapItem
         * @returns {boolean}
         */
        isPair(): boolean;
        /**
         * @type {UplcValue}
         */
        get first(): UplcValue;
        /**
         * @type {UplcValue}
         */
        get second(): UplcValue;
        /**
         * Distinguishes a list from a map
         * @returns {boolean}
         */
        isList(): boolean;
        /**
         * @type {UplcType}
         */
        get itemType(): UplcType;
        /**
         * @type {UplcValue[]}
         */
        get list(): UplcValue[];
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @internal
         * @returns {Promise<UplcValue>}
         */
        force(): Promise<UplcValue>;
        /**
         * @internal
         * @returns {UplcUnit}
         */
        assertUnit(): UplcUnit;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {string}
         */
        typeBits(): string;
        /**
         * Encodes value without type header
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValueInternal(bitWriter: BitWriter): void;
        /**
         * Encodes value with plutus flat encoding.
         * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValue(bitWriter: BitWriter): void;
        #private;
    }
    /**
     * Represents the typeBits of a UPLC primitive.
     */
    export class UplcType {
        /**
         * @returns {UplcType}
         */
        static newDataType(): UplcType;
        /**
         * @returns {UplcType}
         */
        static newDataPairType(): UplcType;
        /**
         * @param {number[]} lst
         * @returns {UplcType}
         */
        static fromNumbers(lst: number[]): UplcType;
        /**
         * @param {string} typeBits
         */
        constructor(typeBits: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @returns {string}
         */
        typeBits(): string;
        /**
         * @param {UplcValue} value
         * @returns {boolean}
         */
        isSameType(value: UplcValue): boolean;
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @returns {boolean}
         */
        isDataPair(): boolean;
        #private;
    }
    /**
     * @typedef {[null | string, UplcValue][]} UplcRawStack
     */
    /**
     * @typedef {{
     *	 onPrint: (msg: string) => Promise<void>
     *   onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>
     *   onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>
     *   onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void
     * }} UplcRTECallbacks
     */
    /**
     * @internal
     * @typedef {UplcRTECallbacks & {
     *   macros?: {[name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>}
     * }} UplcRTECallbacksInternal
     */
    /**
     * @type {UplcRTECallbacks}
     */
    export const DEFAULT_UPLC_RTE_CALLBACKS: UplcRTECallbacks;
    /**
     * Plutus-core Runtime Environment is used for controlling the programming evaluation (eg. by a debugger)
     * @internal
     */
    export class UplcRte {
        /**
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         */
        constructor(callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams);
        /**
         * @type {string[]}
         */
        get messages(): string[];
        /**
         * @returns {string}
         */
        popLastMessage(): string;
        /**
         * @returns {boolean}
         */
        hasError(): boolean;
        /**
         * @returns {string | RuntimeError}
         */
        getError(): string | RuntimeError;
        /**
         * @param {string | RuntimeError} err
         * @returns {UplcValue}
         */
        error(err: string | RuntimeError): UplcValue;
        /**
         * @param {string} name - for breakdown
         * @param {boolean} isTerm
         * @param {Cost} cost
         */
        incrCost(name: string, isTerm: boolean, cost: Cost): void;
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Gets variable using Debruijn index. Throws error here because UplcRTE is the stack root and doesn't contain any values.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         * Creates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the print callback (or does nothing if print callback isn't defined)
         * @param {string | string[]} rawMsg
         * @returns {Promise<void>}
         */
        print(rawMsg: string | string[]): Promise<void>;
        /**
         * Calls the onStartCall callback.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback if '#notifyCalls == true'.
         * '#notifyCalls' is set to true if 'rawStack == #marker'.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * Allows doing a dummy eval of a UplcProgram in order to determine some non-changing properties (eg. the address fetched via the network in a LinkingProgram)
     * @internal
     */
    export class UplcAny extends UplcValue {
    }
    /**
     * @internal
     * @typedef {(callSite: Site, subStack: UplcStack, ...args: UplcValue[]) => (UplcValue | Promise<UplcValue>)} UplcAnonCallback
     */
    /**
     * @internal
     * @typedef {{
     *   rte: UplcRte | UplcStack
     *   nArgs?: number
     *   argNames?: string[]
     *   argCount?: number
     *   fn: UplcAnonCallback
     *   callSite?: Site
     *   allowAnyArgs?: boolean
     * }} UplcAnonProps
     */
    /**
     * Anonymous Plutus-core function.
     * Returns a new UplcAnon whenever it is called/applied (args are 'accumulated'), except final application, when the function itself is evaluated.
     * @internal
     */
    export class UplcAnon extends UplcValue {
        /**
         *
         * @param {Site} site
         * @param {UplcAnonProps} props
         */
        constructor(site: Site, props: UplcAnonProps);
        /**
         * @param {Site} newSite
         * @returns {UplcAnon}
         */
        copy(newSite: Site): UplcAnon;
        /**
         * @param {Site} callSite
         * @param {UplcStack} subStack
         * @param {UplcValue[]} args
         * @returns {UplcValue | Promise<UplcValue>}
         */
        callSync(callSite: Site, subStack: UplcStack, args: UplcValue[]): UplcValue | Promise<UplcValue>;
        #private;
    }
    /**
     * @internal
     */
    export class UplcDelayedValue extends UplcValue {
        /**
         * @param {Site} site
         * @param {() => (UplcValue | Promise<UplcValue>)} evaluator
         */
        constructor(site: Site, evaluator: () => (UplcValue | Promise<UplcValue>));
        #private;
    }
    /**
     * Plutus-core Integer class
     */
    export class UplcInt extends UplcValue {
        /**
         * Constructs a UplcInt without requiring a Site
         * @param {bigint | number} value
         * @returns {UplcInt}
         */
        static new(value: bigint | number): UplcInt;
        /**
         * Creates a UplcInt wrapped in a UplcConst, so it can be used a term
         * @param {Site} site
         * @param {bigint} value
         * @returns
         */
        static newSignedTerm(site: Site, value: bigint): UplcConst;
        /**
         * Parses a single byte in the Plutus-core byte-list representation of an int
         * @param {number} b
         * @returns {number}
         */
        static parseRawByte(b: number): number;
        /**
         * Returns true if 'b' is the last byte in the Plutus-core byte-list representation of an int.
         * @param {number} b
         * @returns {boolean}
         */
        static rawByteIsLast(b: number): boolean;
        /**
         * Combines a list of Plutus-core bytes into a bigint (leading bit of each byte is ignored).
         * Differs from bytesToBigInt in utils.js because only 7 bits are used from each byte.
         * @param {number[]} bytes
         * @returns {bigint}
         */
        static bytesToBigInt(bytes: number[]): bigint;
        /**
         * @param {Site} site
         * @param {bigint} value - supposed to be arbitrary precision
         * @param {boolean} signed - unsigned is only for internal use
         */
        constructor(site: Site, value: bigint, signed?: boolean);
        /**
         * @readonly
         * @type {bigint}
         */
        readonly value: bigint;
        /**
         * @readonly
         * @type {boolean}
         */
        readonly signed: boolean;
        /**
         * @param {Site} newSite
         * @returns {UplcInt}
         */
        copy(newSite: Site): UplcInt;
        /**
         * Applies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().int => 1n
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().toSigned().int => -1n
         * @example
         * (new UplcInt(Site.dummy(), -2n, true)).toUnsigned().toSigned().int => -2n
         * @example
         * (new UplcInt(Site.dummy(), -3n, true)).toUnsigned().toSigned().int => -3n
         * @example
         * (new UplcInt(Site.dummy(), -4n, true)).toUnsigned().toSigned().int => -4n
         * @returns {UplcInt}
         */
        toUnsigned(): UplcInt;
        /**
         * Unapplies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), 1n, false)).toSigned().int => -1n
         * @returns {UplcInt}
        */
        toSigned(): UplcInt;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatInternal(bitWriter: BitWriter): void;
        /**
         * Encodes unsigned integer with plutus flat encoding.
         * Throws error if signed.
         * Used by encoding plutus core program version and debruijn indices.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatUnsigned(bitWriter: BitWriter): void;
    }
    /**
     * Plutus-core ByteArray value class
     * Wraps a regular list of uint8 numbers (so not Uint8Array)
     */
    export class UplcByteArray extends UplcValue {
        /**
         * Construct a UplcByteArray without requiring a Site
         * @internal
         * @param {number[]} bytes
         * @returns {UplcByteArray}
         */
        static new(bytes: number[]): UplcByteArray;
        /**
         * Creates new UplcByteArray wrapped in UplcConst so it can be used as a term.
         * @internal
         * @param {Site} site
         * @param {number[]} bytes
         * @returns {UplcConst}
         */
        static newTerm(site: Site, bytes: number[]): UplcConst;
        /**
         * Write a list of bytes to the bitWriter using flat encoding.
         * Used by UplcString, UplcByteArray and UplcDataValue
         * Equivalent to E_B* function in Plutus-core docs
         * @internal
         * @param {BitWriter} bitWriter
         * @param {number[]} bytes
         */
        static writeBytes(bitWriter: BitWriter, bytes: number[]): void;
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        /**
         * @internal
         * @param {Site} newSite
         * @returns {UplcByteArray}
         */
        copy(newSite: Site): UplcByteArray;
        #private;
    }
    /**
     * Plutus-core string value class
     */
    export class UplcString extends UplcValue {
        /**
         * Constructs a UplcStrin without requiring a Site
         * @param {string} value
         * @returns {UplcString}
         */
        static new(value: string): UplcString;
        /**
         * Creates a new UplcString wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {string} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: string): UplcConst;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        /**
         * @param {Site} newSite
         * @returns {UplcString}
         */
        copy(newSite: Site): UplcString;
        #private;
    }
    /**
     * Plutus-core unit value class
     */
    export class UplcUnit extends UplcValue {
        /**
         * Constructs a UplcUnit without requiring a Site
         * @returns {UplcUnit}
         */
        static new(): UplcUnit;
        /**
         * Creates a new UplcUnit wrapped with UplcConst so it can be used as a term
         * @param {Site} site
         * @returns {UplcConst}
         */
        static newTerm(site: Site): UplcConst;
    }
    /**
     * Plutus-core boolean value class
     */
    export class UplcBool extends UplcValue {
        /**
         * Constructs a UplcBool without requiring a Site
         * @param {boolean} value
         * @returns {UplcBool}
         */
        static new(value: boolean): UplcBool;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {boolean} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: boolean): UplcConst;
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        /**
         * @param {Site} newSite
         * @returns {UplcBool}
         */
        copy(newSite: Site): UplcBool;
        #private;
    }
    /**
     * Plutus-core pair value class
     * Can contain any other value type.
     */
    export class UplcPair extends UplcValue {
        /**
         * Constructs a UplcPair without requiring a Site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcPair}
         */
        static new(first: UplcValue, second: UplcValue): UplcPair;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcConst}
         */
        static newTerm(site: Site, first: UplcValue, second: UplcValue): UplcConst;
        /**
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         */
        constructor(site: Site, first: UplcValue, second: UplcValue);
        /**
         * @param {Site} newSite
         * @returns {UplcPair}
         */
        copy(newSite: Site): UplcPair;
        /**
         * @type {UplcData}
         */
        get key(): UplcData;
        /**
         * @type {UplcData}
         */
        get value(): UplcData;
        #private;
    }
    /**
     * Plutus-core list value class.
     * Only used during evaluation.
    */
    export class UplcList extends UplcValue {
        /**
         * Constructs a UplcList without requiring a Site
         * @param {UplcType} type
         * @param {UplcValue[]} items
         */
        static new(type: UplcType, items: UplcValue[]): UplcList;
        /**
         * @param {Site} site
         * @param {UplcType} itemType
         * @param {UplcValue[]} items
         */
        constructor(site: Site, itemType: UplcType, items: UplcValue[]);
        /**
         * @param {Site} newSite
         * @returns {UplcList}
         */
        copy(newSite: Site): UplcList;
        /**
         * @returns {boolean}
         */
        isDataList(): boolean;
        /**
         * @returns {boolean}
         */
        isDataMap(): boolean;
        #private;
    }
    /**
     * Wrapper for UplcData.
     */
    export class UplcDataValue extends UplcValue {
        /**
         * @param {UplcDataValue | UplcData} data
         * @returns {UplcData}
         */
        static unwrap(data: UplcDataValue | UplcData): UplcData;
        /**
         * @param {Site} site
         * @param {UplcData} data
         */
        constructor(site: Site, data: UplcData);
        /**
         * @param {Site} newSite
         * @returns {UplcDataValue}
         */
        copy(newSite: Site): UplcDataValue;
        #private;
    }
    /**
     * Base class of Plutus-core terms
     */
    export class UplcTerm {
        /**
         * @param {Site} site
         * @param {number} type
         */
        constructor(site: Site, type: number);
        /**
         * @type {number}
         */
        get type(): number;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Generic term toString method
         * @returns {string}
         */
        toString(): string;
        /**
         * Calculates a value, and also increments the cost
         * @internal
         * @param {UplcRte | UplcStack} rte
         * @returns {Promise<UplcValue>}
         */
        eval(rte: UplcRte | UplcStack): Promise<UplcValue>;
        /**
         * Writes bits of flat encoded Plutus-core terms to bitWriter. Doesn't return anything.
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlat(bitWriter: BitWriter, codeMapFileIndices?: null | Map<string, number>): void;
        #private;
    }
    /**
     * Plutus-core variable ref term (index is a Debruijn index)
     */
    export class UplcVariable extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcInt} index
         */
        constructor(site: Site, index: UplcInt);
        /**
         * @readonly
         * @type {UplcInt}
         */
        readonly index: UplcInt;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core delay term.
     */
    export class UplcDelay extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core lambda term
     */
    export class UplcLambda extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         * @param {null | string} argName
         */
        constructor(site: Site, expr: UplcTerm, argName?: null | string);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core function application term (i.e. function call)
     */
    export class UplcCall extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} fn
         * @param {UplcTerm} arg
         */
        constructor(site: Site, fn: UplcTerm, arg: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly fn: UplcTerm;
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly arg: UplcTerm;
        /**
         * @internal
         * @type {Site}
         */
        get callSite(): Site;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core const term (i.e. a literal in conventional sense)
     */
    export class UplcConst extends UplcTerm {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @readonly
         * @type {UplcValue}
         */
        readonly value: UplcValue;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * Plutus-core force term
     */
    export class UplcForce extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core error term
     */
    export class UplcError extends UplcTerm {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core builtin function ref term
     */
    export class UplcBuiltin extends UplcTerm {
        /**
         * Used by IRCoreCallExpr
         * @internal
         * @param {Word} name
         * @param {UplcValue[]} args
         * @returns {UplcValue}
         */
        static evalStatic(name: Word, args: UplcValue[]): UplcValue;
        /**
         * @param {Site} site
         * @param {string | number} name
         */
        constructor(site: Site, name: string | number);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @internal
         * @returns {boolean}
         */
        allowAny(): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        isMacro(): boolean;
        /**
         * @internal
         * @param {NetworkParams} params
         * @param  {...UplcValue} args
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, ...args: UplcValue[]): Cost;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        evalMacro(rte: UplcRte, site: Site, args: UplcValue[]): Promise<UplcValue>;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @returns {UplcValue | Promise<UplcValue>}
         */
        evalBuiltin(rte: UplcRte, site: Site, args: UplcValue[]): UplcValue | Promise<UplcValue>;
        /**
         * @internal
         * @param {UplcRte | UplcStack} rte
         * @returns {UplcAnon}
         */
        evalInternal(rte?: UplcRte | UplcStack): UplcAnon;
        /**
         * @internal
         * @type {number}
         */
        get forceCount(): number;
        #private;
    }
    /**
     * @internal
     */
    export class UplcFrame {
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @returns {Promise<CekState>}
         */
        reduceCek(rte: UplcRte, stack: UplcFrame[], state: ReducingState): Promise<CekState>;
        /**
         * @type {Site}
         */
        get site(): Site;
    }
    /**
     * @internal
     */
    export class ForceFrame extends UplcFrame {
        /**
         * @param {UplcForce} term
         * @param {CekEnv} env
         */
        constructor(term: UplcForce, env: CekEnv);
        /**
         * @readonly
         * @type {UplcForce}
         */
        readonly term: UplcForce;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class PreCallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class CallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {UplcLambdaWithEnv | AppliedUplcBuiltin} fn
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, fn: UplcLambdaWithEnv | AppliedUplcBuiltin, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {UplcLambdaWithEnv | AppliedUplcBuiltin}
         */
        readonly fn: UplcLambdaWithEnv | AppliedUplcBuiltin;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * TODO: purpose as enum type
     * @typedef {{
     *   purpose: null | ScriptPurpose
     *   callsTxTimeRange: boolean
     *   name?: string
     * }} ProgramProperties
     */
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     * @template TInstance
     * @typedef {{
     *   transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance,
     *   transferUplcAst: TransferUplcAst
     * }} TransferableUplcProgram
     */
    /**
     * @typedef {{
    *   mem: bigint,
    *   cpu: bigint,
    *   size?: number,
    *   builtins?: {[name: string]: Cost},
    *   terms?: {[name: string]: Cost},
    *   result?: RuntimeError | UplcValue,
    *   messages?: string[]
    * }} Profile
    *
    *
    * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
    * cpu:  in reference cpu microseconds
    * size: in bytes
    * builtins: breakdown per builtin
    * terms: breakdown per termtype
    * result: result of evaluation
    * messages: printed messages (can be helpful when debugging)
    */
    /**
     * Plutus-core program class
     */
    export class UplcProgram {
        /**
         * @internal
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromCborWithMapping(bytes: number[] | string, files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromCbor(bytes: number[] | string, properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromFlat(bytes: number[], properties?: ProgramProperties): UplcProgram;
        /**
         * @internal
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromFlatWithMapping(bytes: number[], files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * Intended for transfer only
         * @param {any} expr
         * @param {ProgramProperties} properties
         * @param {any[]} version
         * @returns {UplcProgram}
         */
        static transferUplcProgram(expr: any, properties: ProgramProperties, version: any[]): UplcProgram;
        /**
         * @type {TransferUplcAst}
         */
        static get transferUplcAst(): TransferUplcAst;
        /**
         * @param {UplcTerm} expr
         * @param {ProgramProperties} properties
         * @param {UplcInt[]} version
         */
        constructor(expr: UplcTerm, properties?: ProgramProperties, version?: UplcInt[]);
        /**
         * @type {UplcTerm}
         */
        get expr(): UplcTerm;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * Returns the IR source
         * @type {string}
         */
        get src(): string;
        /**
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * @template TInstance
         * @param {TransferableUplcProgram<TInstance>} other
         * @returns {TInstance}
         */
        transfer<TInstance>(other: TransferableUplcProgram<TInstance>): TInstance;
        /**
         * Returns version of Plutus-core (!== Plutus script version!)
         * @type {string}
         */
        get versionString(): string;
        /**
         * @returns {string}
         */
        plutusScriptVersion(): string;
        /**
         * Returns 1 for PlutusScriptV1, 2 for PlutusScriptV2
         * @returns {number}
         */
        versionTag(): number;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Flat encodes the entire Plutus-core program.
         * Note that final padding isn't added now but is handled by bitWriter upon finalization.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlat(bitWriter: BitWriter): void;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlatWithMapping(bitWriter: BitWriter, codeMapFileIndices: null | Map<string, number>): void;
        /**
         * @internal
         * @param {UplcRte} rte
         * @returns {Promise<UplcValue>}
         */
        eval(rte: UplcRte): Promise<UplcValue>;
        /**
         * Evaluates the term contained in UplcProgram (assuming it is a lambda term)
         * @internal
         * @param {null | UplcValue[]} args
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue>}
         */
        runInternal(args: null | UplcValue[], callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams): Promise<UplcValue>;
        /**
         * Wrap the top-level term with consecutive UplcCall terms
         * No checks are performed whether this makes sense or not, so beware
         * Throws an error if you are trying to apply an  with anon func.
         * @param {(UplcValue | HeliosData)[]} args
         * @returns {UplcProgram} - a new UplcProgram instance
         */
        apply(args: (UplcValue | HeliosData)[]): UplcProgram;
        /**
         * @param {null | UplcValue[]} args - if null the top-level term is returned as a value
         * @param {UplcRTECallbacks} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue | RuntimeError>}
         */
        run(args: null | UplcValue[], callbacks?: UplcRTECallbacks, networkParams?: null | NetworkParams): Promise<UplcValue | RuntimeError>;
        /**
         * @param {null | UplcValue[]} args
         * @returns {Promise<[(UplcValue | RuntimeError), string[]]>}
         */
        runWithPrint(args: null | UplcValue[]): Promise<[(UplcValue | RuntimeError), string[]]>;
        /**
         * @param {UplcValue[]} args
         * @param {NetworkParams} networkParams
         * @returns {Promise<Profile>}
         */
        profile(args: UplcValue[], networkParams: NetworkParams): Promise<Profile>;
        /**
         * Returns flat bytes of serialized script
         * @returns {number[]}
         */
        serializeBytes(): number[];
        /**
         * Calculates the on chain size of the program (number of bytes).
         * @returns {number}
         */
        calcSize(): number;
        /**
         * Returns the Cbor encoding of a script (flat bytes wrapped twice in Cbor bytearray)
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @internal
         * @param {Map<string, number>} codeMapFileIndices
         */
        toCborWithMapping(codeMapFileIndices: Map<string, number>): number[];
        /**
         * Returns Plutus-core script in JSON format (as string, not as object!)
         * @returns {string}
         */
        serialize(): string;
        /**
         * @returns {number[]} - 28 byte hash
         */
        hash(): number[];
        /**
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * @type {StakingValidatorHash}
         */
        get stakingValidatorHash(): StakingValidatorHash;
        #private;
    }
    /**
     * @internal
     */
    export class Tokenizer {
        /**
         * @param {Site} site
         * @param {string[]} chars
         * @param {boolean} reverse
         * @returns {string[]}
         */
        static assertCorrectDecimalUnderscores(site: Site, chars: string[], reverse?: boolean): string[];
        /**
         * Separates tokens in fields (separted by commas)
         * @param {Token[]} ts
         * @returns {Group | null}
         */
        static buildGroup(ts: Token[]): Group | null;
        /**
         * @param {Source} src
         * @param {?CodeMap} codeMap
         * @param {boolean} irMode - if true '@' is treated as a regular character
         */
        constructor(src: Source, codeMap?: CodeMap | null, irMode?: boolean);
        incrPos(): void;
        decrPos(): void;
        get currentSite(): Site;
        /**
         * @param {Token} t
         */
        pushToken(t: Token): void;
        /**
         * Reads a single char from the source and advances #pos by one
         * @returns {string}
         */
        readChar(): string;
        /**
         * @returns {string}
         */
        peekChar(): string;
        /**
         * Decreases #pos by one
         */
        unreadChar(): void;
        /**
         * Start reading precisely one token
         * @param {Site} site
         * @param {string} c
         */
        readToken(site: Site, c: string): void;
        /**
         * Tokenize the complete source.
         * Nests groups before returning a list of tokens
         * @returns {Token[] | null}
         */
        tokenize(): Token[] | null;
        /**
         * Returns a generator
         * Use gen.next().value to access to the next Token
         * Doesn't perform any grouping
         * Used for quickly parsing the ScriptPurpose header of a script
         * @returns {Generator<Token>}
         */
        streamTokens(): Generator<Token>;
        /**
         * Reads one word token.
         * Immediately turns "true" or "false" into a BoolLiteral instead of keeping it as Word
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readWord(site: Site, c0: string): void;
        /**
         * Reads and discards a comment if current '/' char is followed by '/' or '*'.
         * Otherwise pushes Symbol('/') onto #ts
         * @param {Site} site
         */
        readMaybeComment(site: Site): void;
        /**
         * Reads and discards a single line comment (from '//' to end-of-line)
         */
        readSingleLineComment(): void;
        /**
         * Reads and discards a multi-line comment (from '/' '*' to '*' '/')
         * @param {Site} site
         */
        readMultiLineComment(site: Site): void;
        /**
         * REads a literal integer
         * @param {Site} site
         */
        readSpecialInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readBinaryInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readOctalInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readHexInteger(site: Site): void;
        /**
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readDecimal(site: Site, c0: string): void;
        /**
         * @param {Site} site
         * @param {string} prefix
         * @param {(c: string) => boolean} valid - checks if character is valid as part of the radix
         */
        readRadixInteger(site: Site, prefix: string, valid: (c: string) => boolean): void;
        /**
         * @param {Site} site
         * @param {string[]} leading
         */
        readFixedPoint(site: Site, leading: string[]): void;
        /**
         * Reads literal hexadecimal representation of ByteArray
         * @param {Site} site
         */
        readByteArray(site: Site): void;
        /**
         * Reads literal string delimited by double quotes.
         * Allows for three escape character: '\\', '\n' and '\t'
         * @param {Site} site
         */
        readString(site: Site): void;
        /**
         * Reads single or double character symbols
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readSymbol(site: Site, c0: string): void;
        /**
         * Match group open with group close symbols in order to form groups.
         * This is recursively applied to nested groups.
         * @param {Token[]} ts
         * @returns {Token[] | null}
         */
        nestGroups(ts: Token[]): Token[] | null;
        #private;
    }
    /**
     * @internal
     */
    export class Common {
        /**
         * @param {Typed} i
         * @param {Type} t
         * @returns {boolean}
         */
        static instanceOf(i: Typed, t: Type): boolean;
        /**
         * @param {Type | Type[]} type
         * @returns {Typed | Multi}
         */
        static toTyped(type: Type | Type[]): Typed | Multi;
        /**
         * Compares two types. Throws an error if neither is a Type.
         * @example
         * Common.typesEq(IntType, IntType) => true
         * @param {Type} a
         * @param {Type} b
         * @returns {boolean}
         */
        static typesEq(a: Type, b: Type): boolean;
        /**
         * @param {Type} type
         */
        static isEnum(type: Type): boolean;
        /**
         * @param {Type} type
         */
        static countEnumMembers(type: Type): number;
        /**
         * @param {TypeClass} tc
         * @returns {string[]}
         */
        static typeClassMembers(tc: TypeClass): string[];
        /**
         * @param {Type} type
         * @param {TypeClass} tc
         * @returns {boolean}
         */
        static typeImplements(type: Type, tc: TypeClass): boolean;
        /**
         * @returns {boolean}
         */
        isParametric(): boolean;
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi;
        /**
         * @type {null | Named}
         */
        get asNamed(): Named;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric;
        /**
         * @type {null | Type}
         */
        get asType(): Type;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @type {boolean}
         */
        get ready(): boolean;
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @returns {Promise<UplcData>}
         */
        jsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
        /**
         * @param {UplcData} data
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcToJs(data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @returns {string}
         */
        toString(): string;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class AllType extends Common implements DataType {
        /**
         * @type {HeliosDataClass<HeliosData> | null}
         */
        get offChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class AnyType extends Common implements DataType {
        get fieldNames(): any[];
        get offChainType(): any;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * Type of special case of no-return value where execution can't continue.
     * @internal
     * @implements {Type}
     */
    export class ErrorType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     */
    export class ArgType {
        /**
         *
         * @param {null | Word} name
         * @param {Type} type
         * @param {boolean} optional
         */
        constructor(name: null | Word, type: Type, optional?: boolean);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {ArgType}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): ArgType;
        /**
         * @param {ArgType} other
         * @returns {boolean}
         */
        isBaseOf(other: ArgType): boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function type with arg types and a return type
     * @internal
     * @implements {Type}
     */
    export class FuncType extends Common implements Type {
        /**
         * @param {Type[] | ArgType[]} argTypes
         * @param {Type | Type[]} retTypes
         */
        constructor(argTypes: Type[] | ArgType[], retTypes: Type | Type[]);
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {number}
         */
        get nNonOptArgs(): number;
        /**
         * @type {number}
         */
        get nOptArgs(): number;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * Checks if arg types are valid.
         * Throws errors if not valid. Returns the return type if valid.
         * @param {Site} site
         * @param {Typed[]} posArgs
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Type[]}
         */
        checkCall(site: Site, posArgs: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Type[];
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {Type[]} argTypes
         * @returns {FuncType}
         */
        inferArgs(site: Site, map: InferenceMap, argTypes: Type[]): FuncType;
        /**
         * Checks if any of 'this' argTypes or retType is same as Type.
         * Only if this checks return true is the association allowed.
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isAssociated(site: Site, type: Type): boolean;
        /**
         * Checks if 'this' is a base type of another FuncType.
         * The number of args needs to be the same.
         * Each argType of the FuncType we are checking against needs to be the same or less specific (i.e. isBaseOf(this.#argTypes[i]))
         * The retType of 'this' needs to be the same or more specific
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * Checks if the type of the first arg is the same as 'type'
         * Also returns false if there are no args.
         * For a method to be a valid instance member its first argument must also be named 'self', but that is checked elsewhere
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isMaybeMethod(site: Site, type: Type): boolean;
        /**
         * Throws an error if name isn't found
         * @param {Site} site
         * @param {string} name
         * @returns {number}
         */
        getNamedIndex(site: Site, name: string): number;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   offChainType?: HeliosDataClass<T> | null,
     *   genOffChainType?: (() => HeliosDataClass<T>) | null
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails,
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericType<T extends HeliosData> extends Common implements DataType {
        /**
         * @param {GenericTypeProps<T>} props
         */
        constructor({ name, path, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericTypeProps<T>);
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<T>}
         */
        get offChainType(): HeliosDataClass<T>;
        /**
         * @type {TypeDetails}
         */
        get typeDetails(): TypeDetails;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         */
        applyInternal(site: Site, map: InferenceMap): {
            name: string;
            path: string;
            fieldNames: string[];
            genInstanceMembers: (self: any) => InstanceMembers;
            genTypeMembers: (self: any) => TypeMembers;
        };
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {string} name
         * @param {string} path
         * @returns {GenericType}
         */
        changeNameAndPath(name: string, path: string): GenericType<any>;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   constrIndex: number,
     *   parentType: DataType,
     *   offChainType?: HeliosDataClass<T>,
     *   genOffChainType?: () => HeliosDataClass<T>,
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers?: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericEnumMemberTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericType<T>}
     */
    export class GenericEnumMemberType<T extends HeliosData> extends GenericType<T> implements EnumMemberType {
        /**
         * @param {GenericEnumMemberTypeProps<T>} props
         */
        constructor({ name, path, constrIndex, parentType, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericEnumMemberTypeProps<T>);
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * @type {DataType}
         */
        get parentType(): DataType;
        #private;
    }
    /**
     * Type of return-value of functions that don't return anything (eg. assert, print, error)
     * @internal
     * @implements {Type}
     */
    export class VoidType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         *
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * A regular non-Func Instance. DataValues can always be compared, serialized, used in containers.
     * @internal
     * @implements {Instance}
     */
    export class DataEntity extends Common implements Instance {
        /**
         * @param {DataType} type
         */
        constructor(type: DataType);
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        #private;
    }
    /**
     * Returned by an error()
     * Special case of no-return-value that indicates that execution can't proceed.
     * @internal
     */
    export class ErrorEntity extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
    }
    /**
     * @internal
     * @implements {Named}
     */
    export class NamedEntity implements Named {
        /**
         * @param {string} name
         * @param {string} path
         * @param {EvalEntity} entity
         */
        constructor(name: string, path: string, entity: EvalEntity);
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric;
        /**
         * @type {null | Type}
         */
        get asType(): Type;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * A callable Instance.
     * @internal
     * @implements {Func}
     */
    export class FuncEntity extends Common implements Func {
        /**
         * @param {FuncType} type
         */
        constructor(type: FuncType);
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * Returns the underlying FuncType directly.
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Wraps multiple return values
     * @internal
     * @implements {Multi}
     */
    export class MultiEntity extends Common implements Multi {
        /**
         * @param {(Typed | Multi)[]} vals
         * @returns {Typed[]}
         */
        static flatten(vals: (Typed | Multi)[]): Typed[];
        /**
         * @param {Typed[]} values
         */
        constructor(values: Typed[]);
        /**
         * @type {Typed[]}
         */
        get values(): Typed[];
        #private;
    }
    /**
     * @internal
     * @implements {Typed}
     */
    export class TypedEntity extends Common implements Typed {
        /**
         * @param {Type} type
         */
        constructor(type: Type);
        /**
         * @type {Type}
         */
        get type(): Type;
        #private;
    }
    /**
     * Returned by functions that don't return anything (eg. assert, error, print)
     * @internal
     * @implements {Instance}
     */
    export class VoidEntity extends Common implements Instance {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
    }
    /**
     * @internal
     * @implements {Namespace}
     */
    export class ModuleNamespace extends Common implements Namespace {
        /**
         * @param {NamespaceMembers} members
         */
        constructor(members: NamespaceMembers);
        /**
         * @type {NamespaceMembers}
         */
        get namespaceMembers(): NamespaceMembers;
        #private;
    }
    /**
     * Builtin bool type
     * @internal
     * @type {DataType}
     */
    export const BoolType: DataType;
    /**
     * Builtin bytearray type
     * @internal
     * @type {DataType}
     */
    export const ByteArrayType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const IntType: DataType;
    /**
     * Type of external data that must be cast/type-checked before using
     * Not named 'Data' in Js because it's too generic
     * @internal
     * @type {DataType}
     */
    export const RawDataType: DataType;
    /**
     * Builtin Real fixed point number type
     * @internal
     * @type {DataType}
     */
    export const RealType: DataType;
    /**
     * Builtin string type
     * @internal
     * @type {DataType}
     */
    export const StringType: DataType;
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericParametricType<T extends HeliosData> extends GenericType<any> implements DataType {
    }
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericEnumMemberType<T>}
     */
    export class GenericParametricEnumMemberType<T extends HeliosData> extends GenericEnumMemberType<T> implements EnumMemberType {
    }
    /**
     * @internal
     * @implements {Type}
     */
    export class TypeClassImpl extends Common implements Type {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {null | ParameterI} parameter - reference to original parameter, which is more unique than name
         */
        constructor(typeClass: TypeClass, name: string, parameter: null | ParameterI);
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * Returns 'true' if 'this' is a base-type of 'type'. Throws an error if 'this' isn't a Type.
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class DataTypeClassImpl extends TypeClassImpl implements DataType {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         */
        constructor(typeClass: TypeClass, name: string, path: string, parameter: null | ParameterI);
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {string}
         */
        get path(): string;
        #private;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class AnyTypeClass extends Common implements TypeClass {
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {Type}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class DefaultTypeClass extends Common implements TypeClass {
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class SummableTypeClass extends Common implements TypeClass {
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {ParameterI}
     */
    export class Parameter implements ParameterI {
        /**
         * @param {string} name - typically "a" or "b"
         * @param {string} path - typicall "__T0" or "__F0"
         * @param {TypeClass} typeClass
         */
        constructor(name: string, path: string, typeClass: TypeClass);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get ref(): Type;
        /**
         * A null TypeClass matches any type
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Only func instances can be parametrics instances,
     *  there are no other kinds of parametric instances
     * @internal
     * @implements {Parametric}
     */
    export class ParametricFunc extends Common implements Parametric {
        /**
         * @param {Parameter[]} params
         * @param {FuncType} fnType
         */
        constructor(params: Parameter[], fnType: FuncType);
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): (...any: any[]) => HeliosDataClass<HeliosData>;
        get params(): Parameter[];
        get fnType(): FuncType;
        /**
         * null TypeClasses aren't included
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
         * Must infer before calling
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
         * @returns {Func}
         */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * @internal
     * @implements {Parametric}
     */
    export class ParametricType extends Common implements Parametric {
        /**
         * @param {{
         * 	 name: string,
         *   offChainType?: ((...any) => HeliosDataClass<HeliosData>)
         *   parameters: Parameter[]
         *   apply: (types: Type[]) => DataType
         * }} props
         */
        constructor({ name, offChainType, parameters, apply }: {
            name: string;
            offChainType?: (...any: any[]) => HeliosDataClass<HeliosData>;
            parameters: Parameter[];
            apply: (types: Type[]) => DataType;
        });
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): (...any: any[]) => HeliosDataClass<HeliosData>;
        /**
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
        * Must infer before calling
        * @param {Site} site
        * @param {Typed[]} args
        * @param {{[name: string]: Typed}} namedArgs
        * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
        * @returns {Func}
        */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * Used by print, error, and assert
     * @internal
     * @implements {Func}
     * @implements {Named}
     */
    export class BuiltinFunc extends Common implements Func, Named {
        /**
         *
         * @param {{
         *   name: string,
         *   type: FuncType
         * }} props
         */
        constructor({ name, type }: {
            name: string;
            type: FuncType;
        });
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Special builtin function that throws an error if condition is false and returns Void
     * @internal
     */
    export const AssertFunc: BuiltinFunc;
    /**
     * Special builtin function that throws an error and returns ErrorInstance (special case of Void)
     * @internal
     */
    export const ErrorFunc: BuiltinFunc;
    /**
     * Special builtin function that prints a message and returns void
     * @internal
     */
    export const PrintFunc: BuiltinFunc;
    /**
     * Builtin list type
     * @internal
     * @type {Parametric}
     */
    export const ListType: Parametric;
    /**
     * Builtin map type (in reality list of key-value pairs)
     * @internal
     * @type {Parametric}
     */
    export const MapType: Parametric;
    /**
     * Builtin option type
     * @internal
     * @type {Parametric}
     */
    export const OptionType: Parametric;
    /**
     * Builtin Duration type
     * @internal
     * @type {DataType}
     */
    export const DurationType: DataType;
    /**
     * Builtin Time type. Opaque alias of Int representing milliseconds since 1970
     * @internal
     * @type {DataType}
     */
    export const TimeType: DataType;
    /**
     * Builtin TimeRange type
     * @internal
     * @type {DataType}
     */
    export const TimeRangeType: DataType;
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptHashType extends GenericType<any> implements DataType {
        /**
         *
         * @param {null | string } name
         * @param {null | HeliosDataClass<HeliosData>} offChainType
         */
        constructor(name?: null | string, offChainType?: null | HeliosDataClass<HeliosData>);
    }
    /**
     * @internal
     * @type {DataType}
     */
    export const scriptHashType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DatumHashType: DataType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const MintingPolicyHashType: ScriptHashType;
    /**
     * Builtin PubKey type
     * @internal
     * @type {DataType}
     */
    export const PubKeyType: DataType;
    /**
     * Builtin PubKeyHash type
     * @internal
     * @type {DataType}
     */
    export const PubKeyHashType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const StakeKeyHashType: DataType;
    /**
     * Builtin StakingHash type
     * @internal
     * @type {DataType}
     */
    export const StakingHashType: DataType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashStakeKeyType: EnumMemberType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashValidatorType: EnumMemberType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const StakingValidatorHashType: ScriptHashType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const ValidatorHashType: ScriptHashType;
    /**
     * Builtin AssetClass type
     * @internal
     * @type {DataType}
     */
    export const AssetClassType: DataType;
    /**
     * Builtin money Value type
     * @internal
     * @type {DataType}
     */
    export const ValueType: DataType;
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class ValuableTypeClass extends DefaultTypeClass implements TypeClass {
    }
    /**
     * Buitin Address type
     * @internal
     * @type {DataType}
     */
    export const AddressType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DCertType: DataType;
    /**
     * Builtin Credential type
     * @internal
     * @type {DataType}
     */
    export const CredentialType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const OutputDatumType: DataType;
    /**
     * Base class for ScriptContext, ContractContext, Scripts and other "macro"-types
     * @internal
     */
    export class MacroType extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @typedef {{[name: string]: ScriptHashType}} ScriptTypes
     */
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptsType extends MacroType implements DataType {
        /**
         * @param {ScriptTypes} scripts
         */
        constructor(scripts: ScriptTypes);
        /**
         * @returns {boolean}
         */
        isEmpty(): boolean;
        #private;
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ScriptContextType extends MacroType implements DataType {
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ContractContextType extends MacroType implements DataType {
    }
    /**
     * @internal
     */
    export const WalletType: GenericType<HeliosData>;
    /**
     * Does this really need to be a class? (i.e. will it be instantiated with some properties)
     * @internal
     */
    export const NetworkType: GenericType<HeliosData>;
    /**
     * Builtin ScriptPurpose type (Minting| Spending| Rewarding | Certifying)
     * @internal
     * @type {DataType}
     */
    export const ScriptPurposeType: DataType;
    /**
     * Builtin StakingCredential type
     * @internal
     * @type {DataType}
     */
    export const StakingCredentialType: DataType;
    /**
     * Builtin StakingPurpose type (Rewarding or Certifying)
     * @internal
     * @type {DataType}
     */
    export const StakingPurposeType: DataType;
    /**
     * @internal
     */
    export const TxBuilderType: GenericType<HeliosData>;
    /**
     * Builtin Tx type
     * @internal
     * @type {DataType}
     */
    export const TxType: DataType;
    /**
     * Builtin TxId type
     * @internal
     * @type {DataType}
     */
    export const TxIdType: DataType;
    /**
     * Builtin TxInput type
     * @internal
     * @type {DataType}
     */
    export const TxInputType: DataType;
    /**
     * Builtin TxOutput type
     * @internal
     * @type {DataType}
     */
    export const TxOutputType: DataType;
    /**
     * Builtin TxOutputId type
     * @internal
     * @type {DataType}
     */
    export const TxOutputIdType: DataType;
    /**
     * @internal
     * @type {{[name: string]: DataType}}
     */
    export const builtinTypes: {
        [name: string]: DataType;
    };
    /**
     * GlobalScope sits above the top-level scope and contains references to all the builtin Values and Types
     * @internal
     */
    export class GlobalScope {
        /**
         * Initialize the GlobalScope with all the builtins
         * @param {ScriptTypes} scriptTypes - types of all the scripts in a contract/ensemble
         * @returns {GlobalScope}
         */
        static new(scriptTypes?: ScriptTypes): GlobalScope;
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a global name, doesn't check for uniqueness
         * Called when initializing GlobalScope
         * @param {string | Word} name
         * @param {EvalEntity} value
         */
        set(name: string | Word, value: EvalEntity): void;
        /**
         * Gets a named value from the scope.
         * Throws an error if not found.
         * @param {Word} name
         * @returns {null | EvalEntity}
         */
        get(name: Word): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * User scope
     * @internal
     * @implements {EvalEntity}
     */
    export class Scope extends Common implements EvalEntity {
        /**
         * @param {GlobalScope | Scope} parent
         * @param {boolean} allowShadowing
         */
        constructor(parent: GlobalScope | Scope, allowShadowing?: boolean);
        /**
         * @type {boolean}
         */
        get allowShadowing(): boolean;
        /**
         * Used by top-scope to loop over all the statements
         */
        get values(): [Word, EvalEntity | Scope, boolean][];
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        setInternal(name: Word, value: EvalEntity | Scope, allowShadowing?: boolean): void;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        set(name: Word, value: EvalEntity | Scope): void;
        /**
         * @param {Word} name
         */
        remove(name: Word): void;
        /**
         * @param {Word} name
         * @returns {null | Scope}
         */
        getScope(name: Word): null | Scope;
        /**
         * Gets a named value from the scope. Throws an error if not found
         * @param {Word} name
         * @param {boolean} dryRun - if false -> don't set used flag
         * @returns {null | EvalEntity | Scope}
         */
        get(name: Word, dryRun?: boolean): null | EvalEntity | Scope;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * Asserts that all named values are user.
         * Throws an error if some are unused.
         * Check is only run if we are in strict mode
         * @param {boolean} onlyIfStrict
         */
        assertAllUsed(onlyIfStrict?: boolean): void;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        isUsed(name: Word): boolean;
        dump(): void;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * TopScope is a special scope that can contain UserTypes
     * @internal
     */
    export class TopScope extends Scope {
        /**
         * @param {GlobalScope} parent
         * @param {boolean} strict
         */
        constructor(parent: GlobalScope, strict?: boolean);
        /**
         * Prepends "__scope__" to name before actually setting scope
         * @param {Word} name
         * @param {Scope} value
         */
        setScope(name: Word, value: Scope): void;
        /**
         * @param {boolean} s
         */
        setStrict(s: boolean): void;
        /**
         * @param {Word} name
         * @returns {ModuleScope}
         */
        getModuleScope(name: Word): ModuleScope;
        #private;
    }
    /**
     * @internal
     */
    export class ModuleScope extends Scope {
    }
    /**
     * Base class of every Type and Instance expression.
     * @internal
     */
    export class Expr extends Token {
        /**
         * Used in switch cases where initial typeExpr is used as memberName instead
         * @param {null | EvalEntity} c
         */
        set cache(arg: EvalEntity);
        /**
         * @type {null | EvalEntity}
         */
        get cache(): EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalAsDataType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalAsType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @returns {null | Typed}
         */
        evalAsTyped(scope: Scope): null | Typed;
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalAsTypedOrMulti(scope: Scope): null | Typed | Multi;
        /**
         * @param {string} indent
         * @returns {IR}
         */
        toIR(indent?: string): IR;
        #private;
    }
    /**
     * Simple reference class (i.e. using a Word)
     * @internal
     */
    export class RefExpr extends Expr {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        #private;
    }
    /**
     * Name::Member expression
     * @internal
     */
    export class PathExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} baseExpr
         * @param {Word} memberName
         */
        constructor(site: Site, baseExpr: Expr, memberName: Word);
        /**
         * @type {Expr}
         */
        get baseExpr(): Expr;
        #private;
    }
    /**
     * Name::Member expression which can instantiate zero field structs and enum members
     * @internal
     */
    export class ValuePathExpr extends PathExpr {
    }
    /**
     * []ItemType
     * @internal
     */
    export class ListTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         */
        constructor(site: Site, itemTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * Map[KeyType]ValueType expression
     * @internal
     */
    export class MapTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr);
        #private;
    }
    /**
     * Iterator[Type1, ...] expr
     * @internal
     */
    export class IteratorTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} itemTypeExprs
         */
        constructor(site: Site, itemTypeExprs: Expr[]);
        #private;
    }
    /**
     * Option[SomeType] expression
     * @internal
     */
    export class OptionTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} someTypeExpr
         */
        constructor(site: Site, someTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * '()' which can only be used as return type of func
     * @internal
     */
    export class VoidTypeExpr extends Expr {
    }
    /**
     * @internal
     */
    export class FuncArgTypeExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} typeExpr
         * @param {boolean} optional
         */
        constructor(site: Site, name: null | Word, typeExpr: Expr, optional: boolean);
        optional: boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        eval(scope: Scope): null | ArgType;
        #private;
    }
    /**
     * (ArgType1, ...) -> RetType expression
     * @internal
     */
    export class FuncTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArgTypeExpr[]} argTypeExprs
         * @param {Expr[]} retTypeExprs
         */
        constructor(site: Site, argTypeExprs: FuncArgTypeExpr[], retTypeExprs: Expr[]);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * expr(...); ...
     * @internal
     */
    export class ChainExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, upstreamExpr: Expr, downstreamExpr: Expr);
        /**
         * @readonly
         * @type {Expr}
         */
        readonly upstreamExpr: Expr;
        /**
         * @readonly
         * @type {Expr}
         */
        readonly downstreamExpr: Expr;
    }
    /**
     * '... = ... ; ...' expression
     * @internal
     */
    export class AssignExpr extends ChainExpr {
        /**
         * @param {Site} site
         * @param {DestructExpr[]} nameTypes
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, nameTypes: DestructExpr[], upstreamExpr: Expr, downstreamExpr: Expr);
        #private;
    }
    /**
     * Helios equivalent of unit
     * @internal
     */
    export class VoidExpr extends Expr {
        /**
         * @param {Scope} scope
         * @returns {Instance}
         */
        evalInternal(scope: Scope): Instance;
    }
    /**
     * Literal expression class (wraps literal tokens)
     * @internal
     */
    export class PrimitiveLiteralExpr extends Expr {
        /**
         * @param {PrimitiveLiteral} primitive
         */
        constructor(primitive: PrimitiveLiteral);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        #private;
    }
    /**
     * Literal UplcData which is the result of parameter substitutions.
     * @internal
     */
    export class LiteralDataExpr extends Expr {
        /**
         * @param {Site} site
         * @param {DataType} type
         * @param {UplcData} data
         */
        constructor(site: Site, type: DataType, data: UplcData);
        /**
         * @internal
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @type {EvalEntity}
         */
        get cache(): EvalEntity;
        #private;
    }
    /**
     * Struct field (part of a literal struct constructor)
     * @internal
     */
    export class StructLiteralField {
        /**
         * @param {null | Word} name
         * @param {Expr} value
         */
        constructor(name: null | Word, value: Expr);
        /**
         * @type {Word}
         */
        get name(): Word;
        get site(): Site;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {string} indent
         * @returns {IR}
         */
        toIR(indent?: string): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Struct literal constructor
     * @internal
     */
    export class StructLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {string} path
         * @param {IR[]} fields
         */
        static toIRInternal(site: Site, path: string, fields: IR[]): IR;
        /**
         * @param {Expr} typeExpr
         * @param {StructLiteralField[]} fields
         */
        constructor(typeExpr: Expr, fields: StructLiteralField[]);
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        #private;
    }
    /**
     * []{...} expression
     * @internal
     */
    export class ListLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         * @param {Expr[]} itemExprs
         */
        constructor(site: Site, itemTypeExpr: Expr, itemExprs: Expr[]);
        /**
         * @type {DataType}
         */
        get itemType(): DataType;
        #private;
    }
    /**
     * Map[...]...{... : ...} expression
     * @internal
     */
    export class MapLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         * @param {[Expr, Expr][]} pairExprs
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr, pairExprs: [Expr, Expr][]);
        /**
         * @type {DataType}
         */
        get keyType(): DataType;
        /**
         * @type {DataType}
         */
        get valueType(): DataType;
        #private;
    }
    /**
     * NameTypePair is base class of FuncArg and DataField (differs from StructLiteralField)
     * @internal
     */
    export class NameTypePair {
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         */
        constructor(name: Word, typeExpr: null | Expr);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * Throws an error if called before evalType()
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {null | Expr}
         */
        get typeExpr(): Expr;
        /**
         * @type {string}
         */
        get typeName(): string;
        /**
         * @returns {boolean}
         */
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        /**
         *
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function argument class
     * @internal
     */
    export class FuncArg extends NameTypePair {
        /**
         * @param {IR} bodyIR
         * @param {string} name
         * @param {IR} defaultIR
         * @returns {IR}
         */
        static wrapWithDefaultInternal(bodyIR: IR, name: string, defaultIR: IR): IR;
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         * @param {null | Expr} defaultValueExpr
         */
        constructor(name: Word, typeExpr: null | Expr, defaultValueExpr?: null | Expr);
        /**
         * @param {Scope} scope
         */
        evalDefault(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        evalArgType(scope: Scope): null | ArgType;
        /**
         * (argName) -> {
         *   <bodyIR>
         * }(
         *   ifThenElse(
         * 		__useoptarg__argName,
         *  	() -> {
         *        argName
         *      },
         *      () -> {
         *        <defaultValueExpr>
         *      }
         *   )()
         * )
         * TODO: indentation
         * @param {IR} bodyIR
         * @returns {IR}
         */
        wrapWithDefault(bodyIR: IR): IR;
        #private;
    }
    /**
     * (..) -> RetTypeExpr {...} expression
     * @internal
     */
    export class FuncLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArg[]} args
         * @param {(null | Expr)[]} retTypeExprs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, args: FuncArg[], retTypeExprs: (null | Expr)[], bodyExpr: Expr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Expr}
         */
        get retExpr(): Expr;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @param {Scope} scope
         * @returns {null | FuncType}
         */
        evalType(scope: Scope): null | FuncType;
        isMethod(): boolean;
        /**
         * @returns {IR}
         */
        argsToIR(): IR;
        /**
         * In reverse order, because later opt args might depend on earlier args
         * @param {IR} innerIR
         * @returns {IR}
         */
        wrapWithDefaultArgs(innerIR: IR): IR;
        /**
         * @param {string} indent
         * @returns {IR}
         */
        toIRInternal(indent?: string): IR;
        #private;
    }
    /**
     * value[...] expression
     * @internal
     */
    export class ParametricExpr extends Expr {
        /**
         * Reused by CallExpr
         * @param {Type[]} paramTypes
         * @returns {string}
         */
        static toApplicationIR(paramTypes: Type[]): string;
        /**
         * @param {Site} site - site of brackets
         * @param {Expr} baseExpr
         * @param {Expr[]} parameters
         */
        constructor(site: Site, baseExpr: Expr, parameters: Expr[]);
        /**
         * @type {Type[]}
         */
        get paramTypes(): Type[];
        #private;
    }
    /**
     * Unary operator expression
     * Note: there are no post-unary operators, only pre
     * @internal
     */
    export class UnaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         */
        constructor(op: SymbolToken, a: Expr);
        /**
         * Turns an op symbol into an internal name
         * @returns {Word}
         */
        translateOp(): Word;
        #private;
    }
    /**
     * @internal
     * @type {{[name: string]: string}}
     */
    export const BINARY_SYMBOLS_MAP: {
        [name: string]: string;
    };
    /**
     * Binary operator expression
     * @internal
     */
    export class BinaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         * @param {Expr} b
         */
        constructor(op: SymbolToken, a: Expr, b: Expr);
        /**
         * @type {Expr}
         */
        get first(): Expr;
        /**
         * @type {Expr}
         */
        get second(): Expr;
        /**
         * Turns op symbol into internal name
         * @param {number} alt
         * @returns {Word}
         */
        translateOp(alt?: number): Word;
        /**
         * @returns {boolean}
         */
        isCommutative(): boolean;
        #private;
    }
    /**
     * Parentheses expression
     * @internal
     */
    export class ParensExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} exprs
         */
        constructor(site: Site, exprs: Expr[]);
        #private;
    }
    /**
     * @internal
     */
    export class CallArgExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} valueExpr
         */
        constructor(site: Site, name: null | Word, valueExpr: Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Expr}
         */
        get valueExpr(): Expr;
        /**
         * @type {EvalEntity}
         */
        get value(): EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        #private;
    }
    /**
     * ...(...) expression
     * @internal
     */
    export class CallExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} fnExpr
         * @param {CallArgExpr[]} argExprs
         */
        constructor(site: Site, fnExpr: Expr, argExprs: CallArgExpr[]);
        get fnExpr(): Expr;
        /**
         * Don't call this inside eval() because param types won't yet be complete.
         * @type {FuncType}
         */
        get fn(): FuncType;
        /**
         * @returns {[Expr[], IR[]]} - first list are positional args, second list named args and remaining opt args
         */
        expandArgs(): [Expr[], IR[]];
        /**
         * @param {string} indent
         * @returns {IR}
         */
        toFnExprIR(indent?: string): IR;
        #private;
    }
    /**
     *  ... . ... expression
     * @internal
     */
    export class MemberExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} objExpr
         * @param {Word} memberName
         */
        constructor(site: Site, objExpr: Expr, memberName: Word);
        /**
         * @param {string} indent
         * @param {string} params - applied type parameters must be inserted Before the call to self
         * @returns {IR}
         */
        toIR(indent?: string, params?: string): IR;
        #private;
    }
    /**
     * if-then-else expression
     * @internal
     */
    export class IfElseExpr extends Expr {
        /**
         * @param {Site} site
         * @param {null | Type} prevType
         * @param {Type} newType
         * @returns {null | Type}
         */
        static reduceBranchType(site: Site, prevType: null | Type, newType: Type): null | Type;
        /**
         * @param {Site} site
         * @param {null | Type[]} prevTypes
         * @param {Typed | Multi} newValue
         * @returns {null | Type[]}
         */
        static reduceBranchMultiType(site: Site, prevTypes: null | Type[], newValue: Typed | Multi): null | Type[];
        /**
         * @param {Site} site
         * @param {Expr[]} conditions
         * @param {Expr[]} branches
         */
        constructor(site: Site, conditions: Expr[], branches: Expr[]);
        #private;
    }
    /**
     * DestructExpr is for the lhs-side of assignments and for switch cases
     * @internal
     */
    export class DestructExpr {
        /**
         * @param {Word} name - use an underscore as a sink
         * @param {null | Expr} typeExpr
         * @param {DestructExpr[]} destructExprs
         */
        constructor(name: Word, typeExpr: null | Expr, destructExprs?: DestructExpr[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @returns {boolean}
         */
        hasDestructExprs(): boolean;
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Throws an error if called before evalType()
         * @type {null | Type}
         */
        get type(): Type;
        /**
         * @type {Word}
         */
        get typeName(): Word;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         */
        evalDestructExprs(scope: Scope, upstreamType: Type): void;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         * @param {number} i
         */
        evalInternal(scope: Scope, upstreamType: Type, i: number): any;
        /**
         * @param {Scope} scope
         * @param {DataType} caseType
         */
        evalInSwitchCase(scope: Scope, caseType: DataType): void;
        /**
         * @param {Scope} scope
         * @param {null | Type} upstreamType
         * @param {number} i
         */
        evalInAssignExpr(scope: Scope, upstreamType: null | Type, i: number): any;
        /**
         * @param {number} argIndex
         * @returns {IR}
         */
        toNameIR(argIndex: number): IR;
        /**
         * @param {number} fieldIndex
         * @returns {string}
         */
        getFieldFn(fieldIndex: number): string;
        /**
         * @param {string} indent
         * @param {IR} inner
         * @param {string} objName
         * @param {number} fieldIndex
         * @param {string} fieldFn
         * @returns {IR}
         */
        wrapDestructIRInternal(indent: string, inner: IR, objName: string, fieldIndex: number, fieldFn: string): IR;
        /**
         * @param {string} indent
         * @param {IR} inner
         * @param {number} argIndex
         * @returns {IR}
         */
        wrapDestructIR(indent: string, inner: IR, argIndex: number): IR;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        #private;
    }
    /**
     * Switch case for a switch expression
     * @internal
     */
    export class SwitchCase extends Token {
        /**
         * @param {Site} site
         * @param {DestructExpr} lhs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, lhs: DestructExpr, bodyExpr: Expr);
        /**
         * @type {Expr}
         */
        get body(): Expr;
        /**
         * Used by parser to check if typeExpr reference the same base enum
         * @type {Word} - word representation of type
         */
        get memberName(): Word;
        isDataMember(): boolean;
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @param {DataType} enumType
         * @returns {null | Multi | Typed}
         */
        evalEnumMember(scope: Scope, enumType: DataType): null | Multi | Typed;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalDataMember(scope: Scope): null | Typed | Multi;
        /**
         * Accept an arg because will be called with the result of the controlexpr
         * @param {string} indent
         * @returns {IR}
         */
        toIR(indent?: string): IR;
        #private;
    }
    /**
     * @internal
     */
    export class UnconstrDataSwitchCase extends SwitchCase {
        /**
         * @param {Site} site
         * @param {?Word} intVarName
         * @param {?Word} lstVarName
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, intVarName: Word | null, lstVarName: Word | null, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @param {Type} enumType
         * @returns {Instance}
         */
        evalEnumMember(scope: Scope, enumType: Type): Instance;
        #private;
    }
    /**
     * Default switch case
     * @internal
     */
    export class SwitchDefault extends Token {
        /**
         * @param {Site} site
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        eval(scope: Scope): null | Typed | Multi;
        /**
         * @param {string} indent
         * @returns {IR}
         */
        toIR(indent?: string): IR;
        #private;
    }
    /**
     * Switch expression for Enum, with SwitchCases and SwitchDefault as children
     * @internal
     */
    export class EnumSwitchExpr extends SwitchExpr {
    }
    /**
     * Switch expression for Data
     * @internal
     */
    export class DataSwitchExpr extends SwitchExpr {
    }
    /**
     * Base class for all statements
     * Doesn't return a value upon calling eval(scope)
     * @internal
     */
    export class Statement extends Token {
        /**
         * @param {Site} site
         * @param {Word} name
         */
        constructor(site: Site, name: Word);
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @param {ModuleScope} scope
         */
        eval(scope: ModuleScope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * Returns IR of statement.
         * No need to specify indent here, because all statements are top-level
         * @param {IRDefinitions} map
         */
        toIR(map: IRDefinitions): void;
        #private;
    }
    /**
     * Each field in `import {...} from <ModuleName>` is given a separate ImportFromStatement
     * @internal
     */
    export class ImportFromStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Word} origName
         * @param {Word} moduleName
         */
        constructor(site: Site, name: Word, origName: Word, moduleName: Word);
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * `import <ModuleName>`
     * @internal
     */
    export class ImportModuleStatement extends Statement {
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * Const value statement
     * @internal
     */
    export class ConstStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Expr} typeExpr - can be null in case of type inference
         * @param {null | Expr} valueExpr
         */
        constructor(site: Site, name: Word, typeExpr: Expr, valueExpr: null | Expr);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @returns {boolean}
         */
        isSet(): boolean;
        /**
         * Use this to change a value of something that is already typechecked.
         * @param {UplcData} data
         */
        changeValueSafe(data: UplcData): void;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates rhs and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        /**
         * @returns {IR}
         */
        toIRInternal(): IR;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameter {
        /**
         * @param {Word} name
         * @param {null | Expr} typeClassExpr
         */
        constructor(name: Word, typeClassExpr: null | Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @param {Scope} scope
         * @param {string} path
         * @returns {null | Parameter}
         */
        eval(scope: Scope, path: string): null | Parameter;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameters {
        /**
         * @param {TypeParameter[]} parameterExprs
         * @param {boolean} isForFunc
         */
        constructor(parameterExprs: TypeParameter[], isForFunc: boolean);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @type {string[]}
         */
        get parameterNames(): string[];
        /**
         * @returns {Parameter[]}
         */
        getParameters(): Parameter[];
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genTypePath(base: string): string;
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genFuncPath(base: string): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {Scope}
         */
        evalParams(scope: Scope): Scope;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | ParametricFunc | FuncType}
         */
        evalParametricFuncType(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType), impl?: any): null | ParametricFunc | FuncType;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | EvalEntity}
         */
        evalParametricFunc(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType)): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @param {Site} site
         * @param {(scope: Scope) => DataType} evalConcrete
         * @returns {[DataType | ParametricType, Scope]}
         */
        createParametricType(scope: Scope, site: Site, evalConcrete: (scope: Scope) => DataType): [DataType | ParametricType, Scope];
        #private;
    }
    /**
     * Single field in struct or enum member
     * @internal
     */
    export class DataField extends NameTypePair {
        /**
         * Throws an error if called before evalType()
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        eval(scope: Scope): null | DataType;
    }
    /**
     * Base class for struct and enum member
     * @internal
     */
    export class DataDefinition {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(site: Site, name: Word, fields: DataField[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {DataField[]}
         */
        get fields(): DataField[];
        /**
         * Returns index of a field.
         * Returns -1 if not found.
         * @param {Word} name
         * @returns {number}
         */
        findField(name: Word): number;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasField(name: Word): boolean;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasMember(name: Word): boolean;
        /**
         * @returns {string}
         */
        toStringFields(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        evalFieldTypes(scope: Scope): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {Type}
         */
        genCopyType(self: Type): Type;
        /**
         * @type {number}
         */
        get nFields(): number;
        /**
         * @param {number} i
         * @returns {DataType}
         */
        getFieldType(i: number): DataType;
        /**
         * @param {string} name
         * @returns {number}
         */
        getFieldIndex(name: string): number;
        /**
         * @param {number} i
         * @returns {string}
         */
        getFieldName(i: number): string;
        /**
         * Gets insance member value.
         * @param {Type} self
         * @returns {InstanceMembers}
         */
        genInstanceMembers(self: Type): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {TypeMembers}
         */
        genTypeMembers(self: Type): TypeMembers;
        /**
         * @returns {[string, string, NamedTypeSchema[]]}
         */
        genTypeDetails(): [string, string, NamedTypeSchema[]];
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @return {Promise<UplcData[]>}
         */
        jsFieldsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData[]>;
        /**
         * @param {UplcData[]} fields
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcFieldsToJs(fields: UplcData[], helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        newToIR(path: string, map: IRDefinitions, constrIndex: number): void;
        /**
         * @internal
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {string[]} getterNames
         * @param {number} constrIndex
         */
        copyToIR(path: string, map: IRDefinitions, getterNames: string[], constrIndex?: number): void;
        /**
         * Doesn't return anything, but sets its IRdef in the map
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        toIR(path: string, map: IRDefinitions, constrIndex: number): void;
        #private;
    }
    /**
     * Struct statement
     * @internal
     */
    export class StructStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {DataField[]} fields
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, fields: DataField[], impl: ImplDefinition);
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Evaluates own type and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        #private;
    }
    /**
     * Function statement
     * (basically just a named FuncLiteralExpr)
     * @internal
     */
    export class FuncStatement extends Statement {
        /**
         * @param {Statement} s
         * @returns {boolean}
         */
        static isMethod(s: Statement): boolean;
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {FuncLiteralExpr} funcExpr
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, funcExpr: FuncLiteralExpr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {Site}
         */
        get retSite(): Site;
        /**
         * Evaluates a function and returns a func value
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates type of a funtion.
         * Separate from evalInternal so we can use this function recursively inside evalInternal
         * @param {Scope} scope
         * @returns {null | ParametricFunc | FuncType}
         */
        evalType(scope: Scope): null | ParametricFunc | FuncType;
        /**
         * Returns IR of function
         * @returns {IR}
         */
        toIRInternal(): IR;
        #private;
    }
    /**
     * EnumMember defintion is similar to a struct definition
     * @internal
     */
    export class EnumMember {
        /**
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(name: Word, fields: DataField[]);
        /**
         * @returns {number}
         */
        get constrIndex(): number;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @param {EnumStatement} parent
         * @param {number} i
        */
        registerParent(parent: EnumStatement, i: number): void;
        /**
         * @type {EnumStatement}
         */
        get parent(): EnumStatement;
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {DataDefinition}
         */
        get dataDefinition(): DataDefinition;
        /**
         * @param {Scope} scope
         */
        evalDataFields(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {(parent: DataType) => EnumMemberType}
         */
        evalType(scope: Scope): (parent: DataType) => EnumMemberType;
        get path(): string;
        /**
         * @param {IRDefinitions} map
         */
        toIR(map: IRDefinitions): void;
        #private;
    }
    /**
     * Enum statement, containing at least one member
     * @internal
     */
    export class EnumStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {EnumMember[]} members
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, members: EnumMember[], impl: ImplDefinition);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @internal
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Returns index of enum member.
         * Returns -1 if not found
         * @param {Word} name
         * @returns {number}
         */
        findEnumMember(name: Word): number;
        /**
         * @param {number} i
         * @returns {EnumMember}
         */
        getEnumMember(i: number): EnumMember;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasEnumMember(name: Word): boolean;
        /**
         * @returns {number}
         */
        get nEnumMembers(): number;
        #private;
    }
    /**
     * Impl statements, which add functions and constants to registry of user types (Struct, Enum Member and Enums)
     * @internal
     */
    export class ImplDefinition {
        /**
         * @param {Expr} selfTypeExpr;
         * @param {(FuncStatement | ConstStatement)[]} statements
         */
        constructor(selfTypeExpr: Expr, statements: (FuncStatement | ConstStatement)[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {TypeMembers}
         */
        genTypeMembers(scope: Scope): TypeMembers;
        /**
         * Doesn't add the common types
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        genInstanceMembers(scope: Scope): InstanceMembers;
        /**
         * @param {Scope} scope
         */
        eval(scope: Scope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * Returns IR of all impl members
         * @param {IRDefinitions} map
         */
        toIR(map: IRDefinitions): void;
        #private;
    }
    /**
     * Scope for IR names.
     * Works like a stack of named values from which a Debruijn index can be derived
     * @internal
     */
    export class IRScope {
        /**
         * Checks if a named builtin exists
         * @param {string} name
         * @param {boolean} strict - if true then throws an error if builtin doesn't exist
         * @returns {boolean}
         */
        static isBuiltin(name: string, strict?: boolean): boolean;
        /**
         * Returns index of a named builtin
         * Throws an error if builtin doesn't exist
         * @param {string} name
         * @returns {number}
         */
        static findBuiltin(name: string): number;
        /**
         * @param {null | IRScope} parent
         * @param {null | IRVariable} variable
         */
        constructor(parent: null | IRScope, variable: null | IRVariable);
        /**
         * Calculates the Debruijn index of a named value. Internal method
         * @param {Word | IRVariable} name
         * @param {number} index
         * @returns {[number, IRVariable]}
         */
        getInternal(name: Word | IRVariable, index: number): [number, IRVariable];
        /**
         * Calculates the Debruijn index.
         * @param {Word | IRVariable} name
         * @returns {[number, IRVariable]}
         */
        get(name: Word | IRVariable): [number, IRVariable];
        #private;
    }
    /**
     * IR class that represents function arguments
     * @internal
     */
    export class IRVariable extends Token {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @param {Map<IRVariable, IRVariable>} newVars
         * @returns {IRVariable}
         */
        copy(newVars: Map<IRVariable, IRVariable>): IRVariable;
        /**
         * @returns {boolean}
         */
        isAlwaysInlineable(): boolean;
        #private;
    }
    /**
     * @internal
     */
    export class IRValue {
        /**
         * @param {IRValue[]} args
         * @returns {?IRValue}
         */
        call(args: IRValue[]): IRValue | null;
        /**
         * @type {null | UplcValue}
         */
        get value(): UplcValue;
    }
    /**
     * @internal
     */
    export class IRFuncValue extends IRValue {
        /**
         * @param {(args: IRValue[]) => ?IRValue} callback
         */
        constructor(callback: (args: IRValue[]) => IRValue | null);
        #private;
    }
    /**
     * @internal
     */
    export class IRLiteralValue extends IRValue {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        #private;
    }
    /**
     * @internal
     */
    export class IRDeferredValue extends IRValue {
        /**
         * @param {() => ?IRValue} deferred
         */
        constructor(deferred: () => IRValue | null);
        #private;
    }
    /**
     * @internal
     */
    export class IRCallStack {
        /**
         * @param {boolean} throwRTErrors
         * @param {?IRCallStack} parent
         * @param {?IRVariable} variable
         * @param {?IRValue} value
         */
        constructor(throwRTErrors: boolean, parent?: IRCallStack | null, variable?: IRVariable | null, value?: IRValue | null);
        get throwRTErrors(): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {?IRValue}
         */
        get(variable: IRVariable): IRValue | null;
        /**
         * @param {IRVariable} variable
         * @param {IRValue} value
         * @returns {IRCallStack}
         */
        set(variable: IRVariable, value: IRValue): IRCallStack;
        /**
         * @returns {string[]}
         */
        dump(): string[];
        #private;
    }
    /**
     * @internal
     * @typedef {Map<IRVariable, IRLiteralExpr>} IRLiteralRegistry
     */
    /**
     * @internal
     */
    export class IRNameExprRegistry {
        /**
         * @param {Map<IRVariable, Set<IRNameExpr>>} map
         */
        constructor(map?: Map<IRVariable, Set<IRNameExpr>>, maybeInsideLoop?: Set<any>);
        /**
         * @param {IRNameExpr} nameExpr
         */
        register(nameExpr: IRNameExpr): void;
        /**
         * Used to prevent inlining upon recursion
         * @param {IRVariable} variable
         */
        registerVariable(variable: IRVariable): void;
        /**
         * @param {IRVariable} variable
         * @returns {number}
         */
        countReferences(variable: IRVariable): number;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        maybeInsideLoop(variable: IRVariable): boolean;
        /**
         * Called whenever recursion is detected
         * @returns {IRNameExprRegistry}
         */
        resetVariables(): IRNameExprRegistry;
        #private;
    }
    /**
     * @internal
     */
    export class IRExprRegistry {
        /**
         * @param {IRNameExprRegistry} nameExprs
         */
        constructor(nameExprs: IRNameExprRegistry);
        /**
         * @param {IRVariable} variable
         * @returns {number}
         */
        countReferences(variable: IRVariable): number;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        maybeInsideLoop(variable: IRVariable): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        isInlineable(variable: IRVariable): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {IRExpr}
         */
        getInlineable(variable: IRVariable): IRExpr;
        /**
         * @param {IRVariable} variable
         * @param {IRExpr} expr
         */
        addInlineable(variable: IRVariable, expr: IRExpr): void;
        #private;
    }
    /**
     * Base class of all Intermediate Representation expressions
     * @internal
     */
    export class IRExpr extends Token {
        /**
         * For pretty printing the IR
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * Link IRNameExprs to variables
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * Turns all IRConstExpr istances into IRLiteralExpr instances
         * @param {IRCallStack} stack
         * @returns {IRExpr}
         */
        evalConstants(stack: IRCallStack): IRExpr;
        /**
         * Evaluates an expression to something (hopefully) literal
         * Returns null if it the result would be worse than the current expression
         * Doesn't return an IRLiteral because the resulting expression might still be an improvement, even if it isn't a literal
         * @param {IRCallStack} stack
         * @returns {?IRValue}
         */
        eval(stack: IRCallStack): IRValue | null;
        /**
         * Used to inline literals and to evaluate IRCoreCallExpr instances with only literal args.
         * @param {IRLiteralRegistry} literals
         * @returns {IRExpr}
         */
        simplifyLiterals(literals: IRLiteralRegistry): IRExpr;
        /**
         * Used before simplifyTopology
         * @param {IRNameExprRegistry} nameExprs
         */
        registerNameExprs(nameExprs: IRNameExprRegistry): void;
        /**
         * Used during inlining/expansion to make sure multiple inlines of IRNameExpr don't interfere when setting the Debruijn index
         * @param {Map<IRVariable, IRVariable>} newVars
         * @returns {IRExpr}
         */
        copy(newVars: Map<IRVariable, IRVariable>): IRExpr;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr}
         */
        simplifyTopology(registry: IRExprRegistry): IRExpr;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr}
         */
        simplifyUnused(registry: IRExprRegistry): IRExpr;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
    }
    /**
     * Intermediate Representation variable reference expression
     * @internal
     */
    export class IRNameExpr extends IRExpr {
        /**
         * @param {Word} name
         * @param {?IRVariable} variable
         * @param {?IRValue} value
         */
        constructor(name: Word, variable?: IRVariable | null, value?: IRValue | null);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * isVariable() should be used to check if a IRNameExpr.variable is equal to a IRVariable (includes special handling of "__core*")
         * @type {IRVariable}
         */
        get variable(): IRVariable;
        /**
         * @internal
         * @returns {boolean}
         */
        isCore(): boolean;
        /**
         * @param {IRVariable} ref
         * @returns {boolean}
         */
        isVariable(ref: IRVariable): boolean;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        removeUnusedCallArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        #private;
    }
    /**
     * IR wrapper for UplcValues, representing literals
     * @internal
     */
    export class IRLiteralExpr extends IRExpr {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @type {UplcValue}
         */
        get value(): UplcValue;
        /**
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): IRLiteralExpr;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        removeUnusedCallArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        /**
         * @returns {UplcConst}
         */
        toUplc(): UplcConst;
        #private;
    }
    /**
     * The IRExpr simplify methods aren't implemented because any IRConstExpr instances should've been eliminated during evalConstants.
     * @internal
     */
    export class IRConstExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRExpr} expr
         */
        constructor(site: Site, expr: IRExpr);
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRConstExpr;
        #private;
    }
    /**
     * IR function expression with some args, that act as the header, and a body expression
     * @internal
     */
    export class IRFuncExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRVariable[]} args
         * @param {IRExpr} body
         */
        constructor(site: Site, args: IRVariable[], body: IRExpr);
        get args(): IRVariable[];
        get body(): IRExpr;
        /**
         * @returns {boolean}
         */
        hasOptArgs(): boolean;
        /**
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): IRFuncExpr;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRFuncExpr}
         */
        simplifyUnused(registry: IRExprRegistry): IRFuncExpr;
        #private;
    }
    /**
     * Base class of IRUserCallExpr and IRCoreCallExpr
     * @internal
     */
    export class IRCallExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(site: Site, argExprs: IRExpr[], parensSite: Site);
        get argExprs(): IRExpr[];
        get parensSite(): Site;
        /**
         * @param {string} indent
         * @returns {string}
         */
        argsToString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNamesInArgs(scope: IRScope): void;
        /**
         * @param {IRCallStack} stack
         * @returns {IRExpr[]}
         */
        evalConstantsInArgs(stack: IRCallStack): IRExpr[];
        /**
         * @param {IRCallStack} stack
         * @returns {?IRValue[]}
         */
        evalArgs(stack: IRCallStack): IRValue[] | null;
        /**
         * @param {IRLiteralRegistry} literals
         * @returns {IRExpr[]}
         */
        simplifyLiteralsInArgs(literals: IRLiteralRegistry): IRExpr[];
        /**
         * @param {IRNameExprRegistry} nameExprs
         */
        registerNameExprsInArgs(nameExprs: IRNameExprRegistry): void;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr[]}
         */
        simplifyTopologyInArgs(registry: IRExprRegistry): IRExpr[];
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr[]}
         */
        simplifyUnusedInArgs(registry: IRExprRegistry): IRExpr[];
        /**
         * @param {UplcTerm} term
         * @returns {UplcTerm}
         */
        toUplcCall(term: UplcTerm): UplcTerm;
        #private;
    }
    /**
     * IR function call of core functions
     * @internal
     */
    export class IRCoreCallExpr extends IRCallExpr {
        /**
         * @param {Site} site
         * @param {boolean} throwRTErrors
         * @param {string} builtinName
         * @param {IRValue[]} args
         * @returns {?IRValue}
         */
        static evalValues(site: Site, throwRTErrors: boolean, builtinName: string, args: IRValue[]): IRValue | null;
        /**
         * @param {Site} site
         * @param {string} name - full name of builtin, including prefix
         * @returns {UplcTerm}
         */
        static newUplcBuiltin(site: Site, name: string): UplcTerm;
        /**
         * @param {Word} name
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(name: Word, argExprs: IRExpr[], parensSite: Site);
        get builtinName(): string;
        /**
         * @returns {boolean}
         */
        isCast(): boolean;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRCoreCallExpr;
        #private;
    }
    /**
     * IR function call of non-core function
     * @internal
     */
    export class IRUserCallExpr extends IRCallExpr {
        /**
         * @param {IRExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         * @returns {IRUserCallExpr}
         */
        static new(fnExpr: IRExpr, argExprs: IRExpr[], parensSite: Site): IRUserCallExpr;
        /**
         * @param {IRExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(fnExpr: IRExpr, argExprs: IRExpr[], parensSite: Site);
        /**
         * @readonly
         * @type {IRExpr}
         */
        readonly fnExpr: IRExpr;
        /**
         * @param {IRLiteralRegistry} literals
         * @returns {(IRExpr[] | IRLiteralExpr)}
         */
        simplifyLiteralsInArgsAndTryEval(literals: IRLiteralRegistry): (IRExpr[] | IRLiteralExpr);
    }
    /**
     * @internal
     */
    export class IRAnonCallExpr extends IRUserCallExpr {
        /**
         * @param {IRFuncExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(fnExpr: IRFuncExpr, argExprs: IRExpr[], parensSite: Site);
        /**
         * Internal function
         * @type {IRFuncExpr}
         */
        get anon(): IRFuncExpr;
        /**
         * @type {IRVariable[]}
         */
        get argVariables(): IRVariable[];
        /**
         * Add args to the stack as IRDeferredValue instances
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): IRLiteralExpr | IRUserCallExpr;
        #private;
    }
    /**
     * @internal
     */
    export class IRNestedAnonCallExpr extends IRUserCallExpr {
        /**
         * @param {IRAnonCallExpr} anon
         * @param {IRExpr[]} outerArgExprs
         * @param {Site} parensSite
         */
        constructor(anon: IRAnonCallExpr, outerArgExprs: IRExpr[], parensSite: Site);
        #private;
    }
    /**
     * @internal
     */
    export class IRFuncDefExpr extends IRAnonCallExpr {
        /**
         * @param {IRFuncExpr} anon
         * @param {IRFuncExpr} defExpr
         * @param {Site} parensSite
         */
        constructor(anon: IRFuncExpr, defExpr: IRFuncExpr, parensSite: Site);
        /**
         * @param {IRExprRegistry} registry
         * @returns {[IRFuncExpr, IRExpr]}
         */
        simplifyRecursionArgs(registry: IRExprRegistry): [IRFuncExpr, IRExpr];
        #private;
    }
    /**
     * Intermediate Representation error call (with optional literal error message)
     * @internal
     */
    export class IRErrorCallExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        #private;
    }
    /**
     * Wrapper for IRFuncExpr, IRCallExpr or IRLiteralExpr
     * @internal
     */
    export class IRProgram {
        /**
         * @param {IRExpr} expr
         * @returns {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        static assertValidRoot(expr: IRExpr): IRFuncExpr | IRCallExpr | IRLiteralExpr;
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {boolean} simplify
         * @param {boolean} throwSimplifyRTErrors - if true -> throw RuntimErrors caught during evaluation steps
         * @param {IRScope} scope
         * @returns {IRProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, simplify?: boolean, throwSimplifyRTErrors?: boolean, scope?: IRScope): IRProgram;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplify(expr: IRExpr): IRExpr;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplifyLiterals(expr: IRExpr): IRExpr;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplifyTopology(expr: IRExpr): IRExpr;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplifyUnused(expr: IRExpr): IRExpr;
        /**
         * @param {IRFuncExpr | IRCallExpr | IRLiteralExpr} expr
         * @param {ProgramProperties} properties
         */
        constructor(expr: IRFuncExpr | IRCallExpr | IRLiteralExpr, properties: ProgramProperties);
        /**
         * @internal
         * @type {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        get expr(): IRLiteralExpr | IRCallExpr | IRFuncExpr;
        /**
         * @internal
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        /**
         * @returns {number}
         */
        calcSize(): number;
        #private;
    }
    /**
     * @internal
     */
    export class IRParametricProgram {
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {number} nParams
         * @param {boolean} simplify
         * @returns {IRParametricProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, nParams: number, simplify?: boolean): IRParametricProgram;
        /**
         * @param {IRProgram} irProgram
         * @param {number} nParams
         */
        constructor(irProgram: IRProgram, nParams: number);
        /**
         * @type {IRProgram}
         */
        get program(): IRProgram;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        #private;
    }
    /**
     * Helios root object
     */
    export class Program {
        /**
         * @internal
         * @param {string} rawSrc
         * @returns {[purpose, Module[]]}
         */
        static parseMainInternal(rawSrc: string): [ScriptPurpose, Module[]];
        /**
         * @internal
         * @param {string} mainName
         * @param {string[]} moduleSrcs
         * @returns {Module[]}
         */
        static parseImports(mainName: string, moduleSrcs?: string[]): Module[];
        /**
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs
         * @returns {[null | ScriptPurpose, Module[]]}
         */
        static parseMain(mainSrc: string, moduleSrcs: string[]): [null | ScriptPurpose, Module[]];
        /**
         * Creates  a new program.
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static new(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {}, config?: ProgramConfig): Program;
        /**
         * Creates  a new program.
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {{[name: string]: Type}} validatorTypes
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static newInternal(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {
            [name: string]: Type;
        }, config?: ProgramConfig): Program;
        /**
         * For top-level statements
         * @internal
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IR}
         */
        static injectMutualRecursions(mainIR: IR, map: IRDefinitions): IR;
        /**
         * Also merges builtins and map
         * @internal
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IRDefinitions}
         */
        static applyTypeParameters(mainIR: IR, map: IRDefinitions): IRDefinitions;
        /**
         * @internal
         * @param {ScriptPurpose} purpose
         * @param {Module[]} modules
         * @param {ProgramConfig} config
         */
        constructor(purpose: ScriptPurpose, modules: Module[], config: ProgramConfig);
        /**
         * @internal
         */
        throwErrors(): void;
        /**
         * @type {ProgramConfig}
         */
        get config(): ProgramConfig;
        /**
         * @internal
         * @type {number}
         */
        get nPosParams(): number;
        /**
         * @internal
         * @type {Type[]}
         */
        get posParams(): Type[];
        /**
         * @internal
         * @type {Module[]}
         */
        get mainImportedModules(): Module[];
        /**
         * @internal
         * @type {MainModule}
         */
        get mainModule(): MainModule;
        /**
         * @internal
         * @type {null | Module}
         */
        get postModule(): Module;
        /**
         * @type {ScriptPurpose}
         */
        get purpose(): ScriptPurpose;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @internal
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
        /**
         * @internal
         * @type {Site}
         */
        get mainRetExprSite(): Site;
        /**
         * @internal
         * @type {string[]}
         */
        get mainArgNames(): string[];
        /**
         * @internal
         * @type {DataType[]}
         */
        get mainArgTypes(): DataType[];
        /**
         * @internal
         * @type {string}
         */
        get mainPath(): string;
        /**
         * @internal
         * @type {Statement[]}
         */
        get mainStatements(): Statement[];
        /**
         * Needed to list the paramTypes, and to call changeParam
         * @internal
         * @type {Statement[]}
         */
        get mainAndPostStatements(): Statement[];
        /**
         * @internal
         * @type {[Statement, boolean][]} - boolean value marks if statement is import or not
         */
        get allStatements(): [Statement, boolean][];
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @param {GlobalScope} globalScope
         * @returns {TopScope}
         */
        evalTypesInternal(globalScope: GlobalScope): TopScope;
        /**
         * @internal
         * @param {{[name: string]: Type}} validatorTypes
         * @returns {TopScope}
         */
        evalTypes(validatorTypes?: {
            [name: string]: Type;
        }): TopScope;
        /**
         * @type {UserTypes}
         */
        get types(): UserTypes;
        /**
         * Fill #types with convenient javascript equivalents of Int, ByteArray etc.
         * @internal
         * @param {TopScope} topScope
         */
        fillTypes(topScope: TopScope): void;
        /**
         * @internal
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @internal
         * @type {{[name: string]: DataType}}
         */
        get paramTypes(): {
            [name: string]: DataType;
        };
        /**
         * Change the literal value of a const statements
         * @internal
         * @param {string} name
         * @param {UplcData} data
         */
        changeParamSafe(name: string, data: UplcData): void;
        /**
         * @internal
         * @param {string} name
         * @returns {ConstStatement | null}
         */
        findConstStatement(name: string): ConstStatement | null;
        /**
         * @internal
         * @param {ConstStatement} constStatement
         * @returns {UplcValue}
         */
        evalConst(constStatement: ConstStatement): UplcValue;
        /**
         * Doesn't use wrapEntryPoint
         * @param {string} name - can be namespace: "Type::ConstName" or "Module::ConstName" or "Module::Type::ConstName"
         * @returns {UplcValue}
         */
        evalParam(name: string): UplcValue;
        /**
         * Use proxy for setting
         * @param {{[name: string]: HeliosData | any}} values
         */
        set parameters(arg: {
            [name: string]: any;
        });
        /**
         * Alternative way to get the parameters as HeliosData instances
         * @returns {{[name: string]: HeliosData | any}}
         */
        get parameters(): {
            [name: string]: any;
        };
        /**
         * @internal
         * @param {(s: Statement, isImport: boolean) => boolean} endCond
         * @returns {IRDefinitions}
         */
        statementsToIR(endCond: (s: Statement, isImport: boolean) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {Set<string>}
         */
        collectAllUsed(ir: IR, definitions: IRDefinitions): Set<string>;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IRDefinitions}
         */
        eliminateUnused(ir: IR, definitions: IRDefinitions): IRDefinitions;
        /**
         * Loops over all statements, until endCond == true (includes the matches statement)
         * Then applies type parameters
         * @internal
         * @param {IR} ir
         * @param {(s: Statement) => boolean} endCond
         * @returns {IRDefinitions}
         */
        fetchDefinitions(ir: IR, endCond: (s: Statement) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IR}
         */
        wrapInner(ir: IR, definitions: IRDefinitions): IR;
        /**
         * @internal
         * @param {IR} ir
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        wrapEntryPoint(ir: IR, extra?: null | IRDefinitions): IR;
        /**
         * @internal
         * @returns {IR}
         */
        toIRInternal(): IR;
        /**
         * @internal
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        toIR(extra?: null | IRDefinitions): IR;
        /**
         * Non-positional named parameters
         * @internal
         * @type {[string, Type][]}
         */
        get requiredParameters(): [string, Type][];
        /**
         * @returns {string}
         */
        prettyIR(simplify?: boolean): string;
        /**
         * @param {boolean} simplify
         * @returns {UplcProgram}
         */
        compile(simplify?: boolean): UplcProgram;
        #private;
    }
    /**
     * @internal
     */
    export class NativeContext {
        /**
         *
         * @param {bigint | null} firstValidSlot
         * @param {bigint | null} lastValidSlot
         * @param {PubKeyHash[]} keys
         */
        constructor(firstValidSlot: bigint | null, lastValidSlot: bigint | null, keys: PubKeyHash[]);
        /**
         * Used by NativeAfter
         * @param {bigint} slot
         * @returns {boolean}
         */
        isAfter(slot: bigint): boolean;
        /**
         *
         * @param {bigint} slot
         * @returns {boolean}
         */
        isBefore(slot: bigint): boolean;
        /**
         *
         * @param {PubKeyHash} key
         * @returns {boolean}
         */
        isSignedBy(key: PubKeyHash): boolean;
        #private;
    }
    /**
     * NativeScript allows creating basic multi-signature and time-based validators.
     *
     * This is a legacy technology, but can be cheaper than using Plutus.
     */
    export class NativeScript extends CborData {
        /**
         * @param {string | number[]} raw
         * @returns {NativeScript}
         */
        static fromCbor(raw: string | number[]): NativeScript;
        /**
         * @param {string | Object} json
         * @returns {NativeScript}
         */
        static fromJson(json: string | any): NativeScript;
        /**
         * @param {number} type
         */
        constructor(type: number);
        /**
         * @returns {number[]}
         */
        typeToCbor(): number[];
        /**
         * @returns {Object}
         */
        toJson(): any;
        /**
         * @internal
         * @param {NativeContext} context
         * @returns {boolean}
         */
        eval(context: NativeContext): boolean;
        /**
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * A NativeScript can be used both as a Validator and as a MintingPolicy
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * A NativeScript can be used both as a Validator and as a MintingPolicy
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        #private;
    }
    export class Tx extends CborData {
        /**
         * @param {number[] | string} raw
         * @returns {Tx}
         */
        static fromCbor(raw: number[] | string): Tx;
        /**
         * Used by bundler for macro finalization
         * @param {UplcData} data
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         * @param {{[name: string]: UplcProgram}} scripts
         * @returns {Promise<Tx>}
         */
        static finalizeUplcData(data: UplcData, networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[], scripts: {
            [name: string]: UplcProgram;
        }): Promise<Tx>;
        /**
         * @type {TxBody}
         */
        get body(): TxBody;
        /**
         * @type {number[]}
         */
        get bodyHash(): number[];
        /**
         * @type {TxWitnesses}
         */
        get witnesses(): TxWitnesses;
        /**
         * Used by emulator to check if tx is valid.
         * @param {bigint} slot
         * @returns {boolean}
         */
        isValid(slot: bigint): boolean;
        /**
         * @param {NetworkParams} networkParams
         * @returns {UplcData}
         */
        toTxData(networkParams: NetworkParams): UplcData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>): Promise<void>;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validFrom(slotOrTime: bigint | Date): Tx;
        /**
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validTo(slotOrTime: bigint | Date): Tx;
        /**
         * Throws error if assets of given mph are already being minted in this transaction
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens - list of pairs of [tokenName, quantity], tokenName can be list of bytes or hex-string
         * @param {UplcDataValue | UplcData | null} redeemer
         * @returns {Tx}
         */
        mintTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][], redeemer: UplcDataValue | UplcData | null): Tx;
        /**
         * @param {TxInput} input
         * @param {null | UplcDataValue | UplcData | HeliosData} rawRedeemer
         * @returns {Tx}
         */
        addInput(input: TxInput, rawRedeemer?: null | UplcDataValue | UplcData | HeliosData): Tx;
        /**
         * @param {TxInput[]} inputs
         * @param {?(UplcDataValue | UplcData | HeliosData)} redeemer
         * @returns {Tx}
         */
        addInputs(inputs: TxInput[], redeemer?: (UplcDataValue | UplcData | HeliosData) | null): Tx;
        /**
         * @param {TxInput} input
         * @param {null | UplcProgram} refScript
         * @returns {Tx}
         */
        addRefInput(input: TxInput, refScript?: null | UplcProgram): Tx;
        /**
         * @param {TxInput[]} inputs
         * @returns {Tx}
         */
        addRefInputs(inputs: TxInput[]): Tx;
        /**
         * @param {TxOutput} output
         * @returns {Tx}
         */
        addOutput(output: TxOutput): Tx;
        /**
         * @param {TxOutput[]} outputs
         * @returns {Tx}
         */
        addOutputs(outputs: TxOutput[]): Tx;
        /**
         * @param {PubKeyHash} hash
         * @returns {Tx}
         */
        addSigner(hash: PubKeyHash): Tx;
        /**
         * Unused scripts are detected during finalize(), in which case an error is thrown
         * Throws error if script was already added before
         * @param {UplcProgram | NativeScript} program
         * @returns {Tx}
         */
        attachScript(program: UplcProgram | NativeScript): Tx;
        /**
         * Usually adding only one collateral input is enough
         * Must be less than the limit in networkParams (eg. 3), or else an error is thrown during finalization
         * @param {TxInput} input
         * @returns {Tx}
         */
        addCollateral(input: TxInput): Tx;
        /**
         * Calculates tx fee (including script execution)
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * Iterates until fee is exact
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         * @param {bigint} fee
         * @returns {bigint}
         */
        setFee(networkParams: NetworkParams, fee: bigint): bigint;
        /**
         * Checks that all necessary scripts are included, and that all included scripts are used
         * Shouldn't be used directly
         */
        checkScripts(): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Promise<void>}
         */
        checkExecutionBudgets(networkParams: NetworkParams): Promise<void>;
        /**
         * @internal
         * @param {Address} changeAddress
         */
        balanceAssets(changeAddress: Address): void;
        /**
         * Calculate the base fee which will be multiplied by the required min collateral percentage
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        estimateCollateralBaseFee(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): bigint;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        balanceCollateral(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): void;
        /**
         * Calculates fee and balances transaction by sending an output back to changeAddress
         * First assumes that change output isn't needed, and if that assumption doesn't result in a balanced transaction the change output is created.
         * Iteratively increments the fee because the fee increase the tx size which in turn increases the fee (always converges within two steps though).
         * Throws error if transaction can't be balanced.
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos - used when there are yet enough inputs to cover everything (eg. due to min output lovelace requirements, or fees)
         * @returns {TxOutput} - changeOutput so the fee can be mutated furthers
         */
        balanceLovelace(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): TxOutput;
        /**
         * @param {NetworkParams} networkParams
         * @param {TxOutput} changeOutput
         */
        correctChangeOutput(networkParams: NetworkParams, changeOutput: TxOutput): void;
        checkBalanced(): void;
        /**
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         */
        syncScriptDataHash(networkParams: NetworkParams): void;
        /**
         * @returns {boolean}
         */
        isSmart(): boolean;
        /**
         * Throws an error if there isn't enough collateral
         * Also throws an error if the script doesn't require collateral, but collateral was actually included
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         */
        checkCollateral(networkParams: NetworkParams): void;
        /**
         * Throws error if tx is too big
         * Shouldn't be used directly
         * @param {NetworkParams} networkParams
         */
        checkSize(networkParams: NetworkParams): void;
        /**
         * Final check that fee is big enough
         * @param {NetworkParams} networkParams
         */
        checkFee(networkParams: NetworkParams): void;
        /**
         * @param {NetworkParams} networkParams
         */
        finalizeValidityTimeRange(networkParams: NetworkParams): void;
        /**
         * Assumes transaction hasn't yet been signed by anyone (i.e. witnesses.signatures is empty)
         * Mutates 'this'
         * Note: this is an async function so that a debugger can optionally be attached in the future
         * @param {NetworkParams} networkParams
         * @param {Address}       changeAddress
         * @param {TxInput[]}        spareUtxos - might be used during balancing if there currently aren't enough inputs
         * @returns {Promise<Tx>}
         */
        finalize(networkParams: NetworkParams, changeAddress: Address, spareUtxos?: TxInput[]): Promise<Tx>;
        /**
         * @type {string}
         */
        get profileReport(): string;
        /**
         * Throws an error if verify==true and signature is invalid
         * Adding many signatures might be a bit slow
         * @param {Signature} signature
         * @param {boolean} verify
         * @returns {Tx}
         */
        addSignature(signature: Signature, verify?: boolean): Tx;
        /**
         * Throws an error if verify==true and any of the signatures is invalid
         * Adding many signatures might be a bit slow
         * @param {Signature[]} signatures
         * @param {boolean} verify
         * @returns {Tx}
         */
        addSignatures(signatures: Signature[], verify?: boolean): Tx;
        /**
         * @param {number} tag
         * @param {Metadata} data
         * @returns {Tx}
         */
        addMetadata(tag: number, data: Metadata): Tx;
        /**
         * @returns {TxId}
         */
        id(): TxId;
        #private;
    }
    /**
     * inputs, minted assets, and withdrawals need to be sorted in order to form a valid transaction
     */
    export class TxBody extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxBody}
         */
        static fromCbor(bytes: number[]): TxBody;
        /**
         * @type {TxInput[]}
         */
        get inputs(): TxInput[];
        /**
         * @type {TxOutput[]}
         */
        get outputs(): TxOutput[];
        get fee(): bigint;
        /**
         * @param {bigint} fee
         */
        setFee(fee: bigint): void;
        /**
         * @type {Assets}
         */
        get minted(): Assets;
        /**
         * @type {TxInput[]}
         */
        get collateral(): TxInput[];
        /**
         * @type {bigint | null}
         */
        get firstValidSlot(): bigint;
        /**
         * @type {bigint | null}
         */
        get lastValidSlot(): bigint;
        /**
         * @type {PubKeyHash[]}
         */
        get signers(): PubKeyHash[];
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * For now simply returns minus infinity to plus infinity (WiP)
         * @param {NetworkParams} networkParams
         * @returns {ConstrData}
         */
        toValidTimeRangeData(networkParams: NetworkParams): ConstrData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>): Promise<void>;
        /**
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {TxId} txId
         * @returns {ConstrData}
         */
        toTxData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, txId: TxId): ConstrData;
        /**
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {number} redeemerIdx
         * @returns {UplcData}
         */
        toScriptContextData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, redeemerIdx: number): UplcData;
        /**
         * @returns {Value}
         */
        sumInputValue(): Value;
        /**
         * Throws error if any part of the sum is negative (i.e. more is burned than input)
         * @returns {Value}
         */
        sumInputAndMintedValue(): Value;
        /**
         * @returns {Assets}
         */
        sumInputAndMintedAssets(): Assets;
        /**
         * @returns {Value}
         */
        sumOutputValue(): Value;
        /**
         * @returns {Assets}
         */
        sumOutputAssets(): Assets;
        /**
         * @param {bigint} slot
         */
        validFrom(slot: bigint): void;
        /**
         * @param {bigint} slot
         */
        validTo(slot: bigint): void;
        /**
         * Throws error if this.#minted already contains mph
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph - minting policy hash
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addMint(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * Used to remove dummy inputs
         * Dummy inputs are needed to be able to correctly estimate fees
         * Throws an error if input doesn't exist in list of inputs
         * Internal use only!
         * @param {TxInput} input
         */
        removeInput(input: TxInput): void;
        /**
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addRefInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * @param {TxOutput} output
         */
        addOutput(output: TxOutput): void;
        /**
         * Used to remove dummy outputs
         * Dummy outputs are needed to be able to correctly estimate fees
         * Throws an error if the output doesn't exist in list of outputs
         * Internal use only!
         * @param {TxOutput} output
         */
        removeOutput(output: TxOutput): void;
        /**
         * @param {PubKeyHash} hash
         * @param {boolean} checkUniqueness
         */
        addSigner(hash: PubKeyHash, checkUniqueness?: boolean): void;
        /**
         * @param {TxInput} input
         */
        addCollateral(input: TxInput): void;
        /**
         * @param {Hash | null} scriptDataHash
         */
        setScriptDataHash(scriptDataHash: Hash | null): void;
        /**
         * @param {Hash} metadataHash
         */
        setMetadataHash(metadataHash: Hash): void;
        /**
         * @param {TxOutput | null} output
         */
        setCollateralReturn(output: TxOutput | null): void;
        /**
         * Calculates the number of dummy signatures needed to get precisely the right tx size
         * @returns {number}
         */
        countUniqueSigners(): number;
        /**
         * Script hashes are found in addresses of TxInputs and hashes of the minted MultiAsset
         * @param {Map<hexstring, number>} set - hashes in hex format
         */
        collectScriptHashes(set: Map<hexstring, number>): void;
        /**
         * Makes sure each output contains the necessary min lovelace
         * @param {NetworkParams} networkParams
         */
        correctOutputs(networkParams: NetworkParams): void;
        /**
         * Checks that each output contains enough lovelace
         * @param {NetworkParams} networkParams
         */
        checkOutputs(networkParams: NetworkParams): void;
        /**
         * @param {NetworkParams} networkParams
         * @param {null | bigint} minCollateral
         */
        checkCollateral(networkParams: NetworkParams, minCollateral: null | bigint): void;
        /**
         * Makes sore inputs, withdrawals, and minted assets are in correct order
         * Mutates
         */
        sort(): void;
        /**
         * Used by (indirectly) by emulator to check if slot range is valid.
         * Note: firstValidSlot == lastValidSlot is allowed
         * @param {bigint} slot
         */
        isValid(slot: bigint): boolean;
        #private;
    }
    /**
     * TxWitnesses represents the non-hashed part of transaction. TxWitnesses contains the signatures, the datums, the redeemers, and the scripts, associated with a given transaction.
     */
    export class TxWitnesses extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxWitnesses}
         */
        static fromCbor(bytes: number[]): TxWitnesses;
        /**
         * @type {Signature[]}
         */
        get signatures(): Signature[];
        /**
         * Returns all the scripts, including the reference scripts
         * @type {(UplcProgram | NativeScript)[]}
         */
        get scripts(): (UplcProgram | NativeScript)[];
        /**
         * @type {Redeemer[]}
         */
        get redeemers(): Redeemer[];
        /**
         * @type {ListData}
         */
        get datums(): ListData;
        /**
         * @param {ValidatorHash | MintingPolicyHash} h
         * @returns {boolean}
         */
        isNativeScript(h: ValidatorHash | MintingPolicyHash): boolean;
        /**
         * @returns {boolean}
         */
        anyScriptCallsTxTimeRange(): boolean;
        /**
         * Throws error if signatures are incorrect
         * @param {number[]} bodyBytes
         */
        verifySignatures(bodyBytes: number[]): void;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * @param {Signature} signature
         */
        addSignature(signature: Signature): void;
        /**
         * @param {number} n
         */
        addDummySignatures(n: number): void;
        removeDummySignatures(): void;
        /**
         * Index is calculated later
         * @param {TxInput} input
         * @param {UplcData} redeemerData
         */
        addSpendingRedeemer(input: TxInput, redeemerData: UplcData): void;
        /**
         * @param {MintingPolicyHash} mph
         * @param {UplcData} redeemerData
         */
        addMintingRedeemer(mph: MintingPolicyHash, redeemerData: UplcData): void;
        /**
         * @param {UplcData} data
         */
        addDatumData(data: UplcData): void;
        /**
         * @param {NativeScript} script
         */
        attachNativeScript(script: NativeScript): void;
        /**
         * Throws error if script was already added before
         * @param {UplcProgram} program
         * @param {boolean} isRef
         */
        attachPlutusScript(program: UplcProgram, isRef?: boolean): void;
        /**
         * Retrieves either a regular script or a reference script
         * @param {Hash} scriptHash - can be ValidatorHash or MintingPolicyHash
         * @returns {UplcProgram}
         */
        getUplcProgram(scriptHash: Hash): UplcProgram;
        /**
         * @internal
         * @param {TxBody} body
         */
        updateRedeemerIndices(body: TxBody): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Hash | null} - returns null if there are no redeemers
         */
        calcScriptDataHash(networkParams: NetworkParams): Hash | null;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         * @param {Redeemer} redeemer
         * @param {UplcData} scriptContext
         * @returns {Promise<Profile>}
         */
        executeRedeemer(networkParams: NetworkParams, body: TxBody, redeemer: Redeemer, scriptContext: UplcData): Promise<Profile>;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeScripts(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {TxBody} body
         */
        executeNativeScripts(body: TxBody): void;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * Reruns all the redeemers to make sure the ex budgets are still correct (can change due to outputs added during rebalancing)
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         */
        checkExecutionBudgets(networkParams: NetworkParams, body: TxBody): Promise<void>;
        /**
         * Throws error if execution budget is exceeded
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkExecutionBudgetLimits(networkParams: NetworkParams): void;
        /**
         * @type {string}
         */
        get profileReport(): string;
        #private;
    }
    /**
     * TxInput base-type
     */
    export class TxInput extends CborData {
        /**
         * @param {UplcData} data
         * @returns {TxInput}
         */
        static fromUplcData(data: UplcData): TxInput;
        /**
         * Deserializes TxOutput format used by wallet connector
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromFullCbor(rawBytes: string | number[]): TxInput;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromCbor(rawBytes: string | number[]): TxInput;
        /**
         * Tx inputs must be ordered.
         * The following function can be used directly by a js array sort
         * @param {TxInput} a
         * @param {TxInput} b
         * @returns {number}
         */
        static comp(a: TxInput, b: TxInput): number;
        /**
         * @param {TxInput[]} inputs
         * @returns {Value}
         */
        static sumValue(inputs: TxInput[]): Value;
        /**
         * @param {TxOutputId} outputId
         * @param {null | TxOutput} output - used during building, not part of serialization
         */
        constructor(outputId: TxOutputId, output?: null | TxOutput);
        /**
         * @readonly
         * @type {TxOutputId}
         */
        readonly outputId: TxOutputId;
        /**
         * @deprecated
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @deprecated
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         *
         * @param {TxInput} other
         * @returns {boolean}
         */
        eq(other: TxInput): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        hasOrigOutput(): boolean;
        /**
         * @internal
         * @param {TxOutput} output
         */
        setOrigOutput(output: TxOutput): void;
        /**
         * @deprecated
         * @type {TxOutput}
         */
        get origOutput(): TxOutput;
        /**
         * Shortcut
         * @type {Value}
         */
        get value(): Value;
        /**
         * Shortcut
         * @type {Address}
         */
        get address(): Address;
        /**
         * @returns {ConstrData}
         */
        toOutputIdData(): ConstrData;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * @returns {number[]}
         */
        toFullCbor(): number[];
        /**
         * @returns {Object}
         */
        dump(): any;
        #private;
    }
    /**
     * TxOutput
     */
    export class TxOutput extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxOutput}
         */
        static fromCbor(bytes: number[]): TxOutput;
        /**
         * @param {UplcData} data
         * @returns {TxOutput}
         */
        static fromUplcData(data: UplcData): TxOutput;
        /**
         * @param {Address} address
         * @param {Value} value
         * @param {null | Datum} datum
         * @param {null | UplcProgram} refScript
         */
        constructor(address: Address, value: Value, datum?: null | Datum, refScript?: null | UplcProgram);
        get address(): Address;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Address} addr
         */
        setAddress(addr: Address): void;
        get value(): Value;
        /**
         * Mutation is handy when correcting the quantity of lovelace in a utxo
         * @param {Value} val
         */
        setValue(val: Value): void;
        get datum(): Datum;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Datum} datum
         */
        setDatum(datum: Datum): void;
        /**
         * @returns {UplcData}
         */
        getDatumData(): UplcData;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * Each UTxO must contain some minimum quantity of lovelace to avoid that the blockchain is used for data storage
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        calcMinLovelace(networkParams: NetworkParams): bigint;
        /**
         * Mutates. Makes sure the output contains at least the minimum quantity of lovelace.
         * Other parts of the output can optionally also be mutated
         * @param {NetworkParams} networkParams
         * @param {?((output: TxOutput) => void)} updater
         */
        correctLovelace(networkParams: NetworkParams, updater?: (output: TxOutput) => void): void;
        #private;
    }
    /**
     * Convenience address that is used to query all assets controlled by a given StakeHash (can be scriptHash or regular stakeHash)
     */
    export class StakeAddress {
        /**
         * @param {StakeAddress} sa
         * @returns {boolean}
         */
        static isForTestnet(sa: StakeAddress): boolean;
        /**
         * Convert regular Address into StakeAddress.
         * Throws an error if the given Address doesn't have a staking part.
         * @param {Address} addr
         * @returns {StakeAddress}
         */
        static fromAddress(addr: Address): StakeAddress;
        /**
         * @param {number[]} bytes
         * @returns {StakeAddress}
         */
        static fromCbor(bytes: number[]): StakeAddress;
        /**
         * @param {string} str
         * @returns {StakeAddress}
         */
        static fromBech32(str: string): StakeAddress;
        /**
         * Doesn't check validity
         * @param {string} hex
         * @returns {StakeAddress}
         */
        static fromHex(hex: string): StakeAddress;
        /**
         * Address with only staking part (regular StakeKeyHash)
         * @param {boolean} isTestnet
         * @param {StakeKeyHash} hash
         * @returns {StakeAddress}
         */
        static fromStakeKeyHash(isTestnet: boolean, hash: StakeKeyHash): StakeAddress;
        /**
         * Address with only staking part (script StakingValidatorHash)
         * @param {boolean} isTestnet
         * @param {StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromStakingValidatorHash(isTestnet: boolean, hash: StakingValidatorHash): StakeAddress;
        /**
         * @param {boolean} isTestnet
         * @param {StakeKeyHash | StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromHash(isTestnet: boolean, hash: StakeKeyHash | StakingValidatorHash): StakeAddress;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toBech32(): string;
        /**
         * Returns the raw StakeAddress bytes as a hex encoded string
         * @returns {string}
         */
        toHex(): string;
        /**
         * @returns {StakeKeyHash | StakingValidatorHash}
         */
        get stakingHash(): StakeKeyHash | StakingValidatorHash;
        #private;
    }
    /**
     * Represents a Ed25519 signature.
     *
     * Also contains a reference to the PubKey that did the signing.
     */
    export class Signature extends CborData {
        /**
         * @returns {Signature}
         */
        static dummy(): Signature;
        /**
         * @param {number[]} bytes
         * @returns {Signature}
         */
        static fromCbor(bytes: number[]): Signature;
        /**
         * @param {number[] | PubKey} pubKey
         * @param {number[]} signature
         */
        constructor(pubKey: number[] | PubKey, signature: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Throws error if incorrect
         * @param {number[]} msg
         */
        verify(msg: number[]): void;
        #private;
    }
    /**
     * @typedef {{
     *   derivePubKey(): PubKey
     *   sign(msg: number[]): Signature
     * }} PrivateKey
     */
    /**
     * @implements {PrivateKey}
     */
    export class Ed25519PrivateKey extends HeliosData implements PrivateKey {
        /**
         * Generate a private key from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Ed25519PrivateKey} - Ed25519 private key is 32 bytes long
         */
        static random(random: NumberGenerator): Ed25519PrivateKey;
        /**
         * @param {string | number[]} bytes
         */
        constructor(bytes: string | number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get hex(): string;
        /**
         * NOT the Ed25519-Bip32 hierarchial extension algorithm (see ExtendedPrivateKey below)
         * @returns {Ed25519PrivateKey}
         */
        extend(): Ed25519PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Used during Bip32PrivateKey derivation, to create a new Bip32PrivateKey instance with a non-publicly deriveable PubKey.
     */
    export const BIP32_HARDEN: 2147483648;
    /**
     * Ed25519-Bip32 extendable PrivateKey (ss)
     * @implements {PrivateKey}
     */
    export class Bip32PrivateKey implements PrivateKey {
        /**
         * Generate a bip32private key from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Bip32PrivateKey}
         */
        static random(random: NumberGenerator): Bip32PrivateKey;
        /**
         * @param {number[]} entropy
         * @param {boolean} force
         */
        static fromBip39Entropy(entropy: number[], force?: boolean): Bip32PrivateKey;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @private
         * @type {number[]}
         */
        private get k();
        /**
         * @private
         * @type {number[]}
         */
        private get kl();
        /**
         * @private
         * @type {number[]}
         */
        private get kr();
        /**
         * @private
         * @type {number[]}
         */
        private get c();
        /**
         * @private
         * @param {number} i - child index
         */
        private calcChildZ;
        /**
         * @private
         * @param {number} i
         */
        private calcChildC;
        /**
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @example
         * (new Bip32PrivateKey([0x60, 0xd3, 0x99, 0xda, 0x83, 0xef, 0x80, 0xd8, 0xd4, 0xf8, 0xd2, 0x23, 0x23, 0x9e, 0xfd, 0xc2, 0xb8, 0xfe, 0xf3, 0x87, 0xe1, 0xb5, 0x21, 0x91, 0x37, 0xff, 0xb4, 0xe8, 0xfb, 0xde, 0xa1, 0x5a, 0xdc, 0x93, 0x66, 0xb7, 0xd0, 0x03, 0xaf, 0x37, 0xc1, 0x13, 0x96, 0xde, 0x9a, 0x83, 0x73, 0x4e, 0x30, 0xe0, 0x5e, 0x85, 0x1e, 0xfa, 0x32, 0x74, 0x5c, 0x9c, 0xd7, 0xb4, 0x27, 0x12, 0xc8, 0x90, 0x60, 0x87, 0x63, 0x77, 0x0e, 0xdd, 0xf7, 0x72, 0x48, 0xab, 0x65, 0x29, 0x84, 0xb2, 0x1b, 0x84, 0x97, 0x60, 0xd1, 0xda, 0x74, 0xa6, 0xf5, 0xbd, 0x63, 0x3c, 0xe4, 0x1a, 0xdc, 0xee, 0xf0, 0x7a])).sign(textToBytes("Hello World")).bytes => [0x90, 0x19, 0x4d, 0x57, 0xcd, 0xe4, 0xfd, 0xad, 0xd0, 0x1e, 0xb7, 0xcf, 0x16, 0x17, 0x80, 0xc2, 0x77, 0xe1, 0x29, 0xfc, 0x71, 0x35, 0xb9, 0x77, 0x79, 0xa3, 0x26, 0x88, 0x37, 0xe4, 0xcd, 0x2e, 0x94, 0x44, 0xb9, 0xbb, 0x91, 0xc0, 0xe8, 0x4d, 0x23, 0xbb, 0xa8, 0x70, 0xdf, 0x3c, 0x4b, 0xda, 0x91, 0xa1, 0x10, 0xef, 0x73, 0x56, 0x38, 0xfa, 0x7a, 0x34, 0xea, 0x20, 0x46, 0xd4, 0xbe, 0x04]
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * @implements {PrivateKey}
     */
    export class RootPrivateKey implements PrivateKey {
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {boolean}
         */
        static isValidPhrase(phrase: string[], dict?: string[]): boolean;
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {RootPrivateKey}
         */
        static fromPhrase(phrase: string[], dict?: string[]): RootPrivateKey;
        /**
         * @param {number[]} entropy
         */
        constructor(entropy: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {number[]}
         */
        get entropy(): number[];
        /**
         * @param {string[]} dict
         * @returns {string[]}
         */
        toPhrase(dict?: string[]): string[];
        /**
         * @param {number} i - childIndex
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingRootKey(accountIndex?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveStakingRootKey(accountIndex: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveStakingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Base-type of SpendingRedeemer and MintingRedeemer
     */
    export class Redeemer extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Redeemer}
         */
        static fromCbor(bytes: number[]): Redeemer;
        /**
         * @param {UplcData} data
         * @param {Profile} profile
         */
        constructor(data: UplcData, profile?: Profile);
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @type {bigint}
         */
        get memCost(): bigint;
        /**
         * @type {bigint}
         */
        get cpuCost(): bigint;
        /**
         * @param {string} name
         */
        setProgramName(name: string): void;
        /**
         * @type {null | string}
         */
        get programName(): string;
        /**
         * type:
         *   0 -> spending
         *   1 -> minting
         *   2 -> certifying
         *   3 -> rewarding
         * @param {number} type
         * @param {number} index
         * @returns {number[]}
         */
        toCborInternal(type: number, index: number): number[];
        /**
         * @returns {Object}
         */
        dumpInternal(): any;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @param {TxBody} body
         * @returns {ConstrData}
         */
        toScriptPurposeData(body: TxBody): ConstrData;
        /**
         * @param {TxBody} body
         */
        updateIndex(body: TxBody): void;
        /**
         * @param {Profile} profile
         */
        setProfile(profile: Profile): void;
        /**
         * @type {Profile}
         */
        get profile(): Profile;
        /**
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        #private;
    }
    export class SpendingRedeemer extends Redeemer {
        /**
         * @param {null | TxInput} input
         * @param {number} inputIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(input: null | TxInput, inputIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get inputIndex(): number;
        #private;
    }
    export class MintingRedeemer extends Redeemer {
        /**
         * @param {?MintingPolicyHash} mph
         * @param {number} mphIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(mph: MintingPolicyHash | null, mphIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get mphIndex(): number;
        #private;
    }
    /**
     * Inside helios this type is named OutputDatum in order to distinguish it from the user defined Datum,
     * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum
     */
    export class Datum extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Datum}
         */
        static fromCbor(bytes: number[]): Datum;
        /**
         * @param {UplcData} data
         * @returns {null | Datum}
         */
        static fromUplcData(data: UplcData): null | Datum;
        /**
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static hashed(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static inline(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @returns {boolean}
         */
        isInline(): boolean;
        /**
         * @returns {boolean}
         */
        isHashed(): boolean;
        /**
         * @type {DatumHash}
         */
        get hash(): DatumHash;
        /**
         * @type {?UplcData}
         */
        get data(): UplcData;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
    }
    /**
     * Inside helios this type is named OutputDatum::Hash in order to distinguish it from the user defined Datum,
     * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum
     */
    export class HashedDatum extends Datum {
        /**
         * @param {UplcData} data
         * @returns {HashedDatum}
         */
        static fromData(data: UplcData): HashedDatum;
        /**
         * @param {DatumHash} hash
         * @param {null | UplcData} origData
         */
        constructor(hash: DatumHash, origData?: null | UplcData);
        #private;
    }
    /**
     * @typedef {(utxos: TxInput[], amount: Value) => [TxInput[], TxInput[]]} CoinSelectionAlgorithm
     */
    /**
     * Collection of coin selection algorithms
     */
    export class CoinSelection {
        /**
         * @param {TxInput[]} utxos
         * @param {Value} amount
         * @param {boolean} largestFirst
         * @returns {[TxInput[], TxInput[]]} - [picked, not picked that can be used as spares]
         */
        static selectExtremumFirst(utxos: TxInput[], amount: Value, largestFirst: boolean): [TxInput[], TxInput[]];
        static selectSmallestFirst(utxos: TxInput[], amount: Value): [TxInput[], TxInput[]];
        static selectLargestFirst(utxos: TxInput[], amount: Value): [TxInput[], TxInput[]];
    }
    /**
     * @typedef {{
     *     isMainnet(): Promise<boolean>,
     *     usedAddresses: Promise<Address[]>,
     *     unusedAddresses: Promise<Address[]>,
     *     utxos: Promise<TxInput[]>,
     *     collateral: Promise<TxInput[]>,
     *     signTx(tx: Tx): Promise<Signature[]>,
     *     submitTx(tx: Tx): Promise<TxId>
     * }} Wallet
     */
    /**
     * @typedef {{
     *     getNetworkId(): Promise<number>,
     *     getUsedAddresses(): Promise<string[]>,
     *     getUnusedAddresses(): Promise<string[]>,
     *     getUtxos(): Promise<string[]>,
     *     getCollateral(): Promise<string[]>,
     *     signTx(txHex: string, partialSign: boolean): Promise<string>,
     *     submitTx(txHex: string): Promise<string>,
     *     experimental: {
     *         getCollateral(): Promise<string[]>
     *     },
     * }} Cip30Handle
     */
    /**
     * @implements {Wallet}
     */
    export class Cip30Wallet implements Wallet {
        /**
         * @param {Cip30Handle} handle
         */
        constructor(handle: Cip30Handle);
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * Wraps an instance implementing the Wallet interface in order to provide additional functionality.
     */
    export class WalletHelper {
        /**
         * @param {Wallet} wallet
         * @param {undefined | ((addr: Address[]) => Promise<TxInput[]>)} getUtxosFallback
         */
        constructor(wallet: Wallet, getUtxosFallback?: (addr: Address[]) => Promise<TxInput[]>);
        /**
         * @type {Promise<Address[]>}
         */
        get allAddresses(): Promise<Address[]>;
        /**
         * @returns {Promise<Value>}
         */
        calcBalance(): Promise<Value>;
        /**
         * @type {Promise<Address>}
         */
        get baseAddress(): Promise<Address>;
        /**
         * @type {Promise<Address>}
         */
        get changeAddress(): Promise<Address>;
        /**
         * Returns the first UTxO, so the caller can check precisely which network the user is connected to (eg. preview or preprod)
         * @type {Promise<null | TxInput>}
         */
        get refUtxo(): Promise<TxInput>;
        /**
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(): Promise<TxInput[]>;
        /**
         * @param {Value} amount
         * @param {CoinSelectionAlgorithm} algorithm
         * @returns {Promise<[TxInput[], TxInput[]]>} - [picked, not picked that can be used as spares]
         */
        pickUtxos(amount: Value, algorithm?: CoinSelectionAlgorithm): Promise<[TxInput[], TxInput[]]>;
        /**
         * Returned collateral can't contain an native assets (pure lovelace)
         * TODO: combine UTxOs if a single UTxO isn't enough
         * @param {bigint} amount - 2 Ada should cover most things
         * @returns {Promise<TxInput>}
         */
        pickCollateral(amount?: bigint): Promise<TxInput>;
        /**
         * @param {Address} addr
         * @returns {Promise<boolean>}
         */
        isOwnAddress(addr: Address): Promise<boolean>;
        /**
         * @param {PubKeyHash} pkh
         * @returns {Promise<boolean>}
         */
        isOwnPubKeyHash(pkh: PubKeyHash): Promise<boolean>;
        /**
         * @param {undefined | ((addrs: Address[]) => Promise<TxInput[]>)} utxosFallback
         * @returns {Promise<any>}
         */
        toJson(utxosFallback?: (addrs: Address[]) => Promise<TxInput[]>): Promise<any>;
        #private;
    }
    /**
     * @implements {Wallet}
     */
    export class RemoteWallet implements Wallet {
        /**
         * @param {string | Object} obj
         * @returns {RemoteWallet}
         */
        static fromJson(obj: string | any): RemoteWallet;
        /**
         * @param {boolean} isMainnet
         * @param {Address[]} usedAddresses
         * @param {Address[]} unusedAddresses
         * @param {TxInput[]} utxos
         */
        constructor(isMainnet: boolean, usedAddresses: Address[], unusedAddresses: Address[], utxos: TxInput[]);
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * @typedef {{
     *     getUtxos(address: Address): Promise<TxInput[]>
     *     getUtxo(id: TxOutputId): Promise<TxInput>
     *     getParameters(): Promise<NetworkParams>
     *     submitTx(tx: Tx): Promise<TxId>
     * }} Network
     */
    /**
     * @implements {Network}
     */
    export class BlockfrostV0 implements Network {
        /**
         * Determine the network which the wallet is connected to.
         * @param {Wallet} wallet
         * @param {{
         *     preview?: string,
         *     preprod?: string,
         *     mainnet?: string
         * }} projectIds
         * @returns {Promise<BlockfrostV0>}
         */
        static resolve(wallet: Wallet, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
         * @param {any} obj
         * @returns
         */
        static parseValue(obj: any): Value;
        /**
         * @param {string} networkName - "preview", "preprod" or "mainnet"
         * @param {string} projectId
         */
        constructor(networkName: string, projectId: string);
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @returns {Promise<any>}
         */
        getLatestEpoch(): Promise<any>;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * Used by BlockfrostV0.resolve()
         * @param {TxInput} utxo
         * @returns {Promise<boolean>}
         */
        hasUtxo(utxo: TxInput): Promise<boolean>;
        /**
         * Returns oldest UTxOs first, newest last.
         * TODO: pagination
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    export namespace rawNetworkEmulatorParams {
        namespace shelleyGenesis {
            const activeSlotsCoeff: number;
            const epochLength: number;
            const genDelegs: {
                "637f2e950b0fd8f8e3e811c5fbeb19e411e7a2bf37272b84b29c1a0b": {
                    delegate: string;
                    vrf: string;
                };
                "8a4b77c4f534f8b8cc6f269e5ebb7ba77fa63a476e50e05e66d7051c": {
                    delegate: string;
                    vrf: string;
                };
                b00470cd193d67aac47c373602fccd4195aad3002c169b5570de1126: {
                    delegate: string;
                    vrf: string;
                };
                b260ffdb6eba541fcf18601923457307647dce807851b9d19da133ab: {
                    delegate: string;
                    vrf: string;
                };
                ced1599fd821a39593e00592e5292bdc1437ae0f7af388ef5257344a: {
                    delegate: string;
                    vrf: string;
                };
                dd2a7d71a05bed11db61555ba4c658cb1ce06c8024193d064f2a66ae: {
                    delegate: string;
                    vrf: string;
                };
                f3b9e74f7d0f24d2314ea5dfbca94b65b2059d1ff94d97436b82d5b4: {
                    delegate: string;
                    vrf: string;
                };
            };
            const initialFunds: {};
            const maxKESEvolutions: number;
            const maxLovelaceSupply: number;
            const networkId: string;
            const networkMagic: number;
            namespace protocolParams {
                const a0: number;
                const decentralisationParam: number;
                const eMax: number;
                namespace extraEntropy {
                    const tag: string;
                }
                const keyDeposit: number;
                const maxBlockBodySize: number;
                const maxBlockHeaderSize: number;
                const maxTxSize: number;
                const minFeeA: number;
                const minFeeB: number;
                const minPoolCost: number;
                const minUTxOValue: number;
                const nOpt: number;
                const poolDeposit: number;
                namespace protocolVersion {
                    const major: number;
                    const minor: number;
                }
                const rho: number;
                const tau: number;
            }
            const securityParam: number;
            const slotLength: number;
            const slotsPerKESPeriod: number;
            namespace staking {
                const pools: {};
                const stake: {};
            }
            const systemStart: string;
            const updateQuorum: number;
        }
        namespace alonzoGenesis {
            const lovelacePerUTxOWord: number;
            namespace executionPrices {
                namespace prSteps {
                    const numerator: number;
                    const denominator: number;
                }
                namespace prMem {
                    const numerator_1: number;
                    export { numerator_1 as numerator };
                    const denominator_1: number;
                    export { denominator_1 as denominator };
                }
            }
            namespace maxTxExUnits {
                const exUnitsMem: number;
                const exUnitsSteps: number;
            }
            namespace maxBlockExUnits {
                const exUnitsMem_1: number;
                export { exUnitsMem_1 as exUnitsMem };
                const exUnitsSteps_1: number;
                export { exUnitsSteps_1 as exUnitsSteps };
            }
            const maxValueSize: number;
            const collateralPercentage: number;
            const maxCollateralInputs: number;
            namespace costModels {
                const PlutusV1: {
                    "sha2_256-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "blake2b-cpu-arguments-slope": number;
                    "iData-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "unBData-cpu-arguments": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "cekConstCost-exBudgetMemory": number;
                    "nullList-cpu-arguments": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "trace-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "bData-cpu-arguments": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "unIData-cpu-arguments": number;
                    "consByteString-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "listData-cpu-arguments": number;
                    "headList-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "unMapData-cpu-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "mkCons-cpu-arguments": number;
                    "appendString-memory-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "ifThenElse-cpu-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "chooseList-memory-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "equalsData-memory-arguments": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "lengthOfByteString-memory-arguments": number;
                    "headList-memory-arguments": number;
                    "listData-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "unIData-memory-arguments": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "bData-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "unListData-memory-arguments": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "cekVarCost-exBudgetCPU": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "cekForceCost-exBudgetCPU": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "addInteger-memory-arguments-intercept": number;
                    "chooseUnit-cpu-arguments": number;
                    "sndPair-cpu-arguments": number;
                    "cekLamCost-exBudgetCPU": number;
                    "fstPair-cpu-arguments": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "fstPair-memory-arguments": number;
                    "modInteger-memory-arguments-intercept": number;
                    "unConstrData-cpu-arguments": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "sndPair-memory-arguments": number;
                    "addInteger-cpu-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "mapData-cpu-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "consByteString-memory-arguments-slope": number;
                    "cekVarCost-exBudgetMemory": number;
                    "indexByteString-cpu-arguments": number;
                    "unListData-cpu-arguments": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "cekForceCost-exBudgetMemory": number;
                    "blake2b-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "tailList-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "modInteger-memory-arguments-slope": number;
                    "addInteger-cpu-arguments-slope": number;
                    "equalsData-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "chooseList-cpu-arguments": number;
                    "constrData-cpu-arguments": number;
                    "equalsByteString-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "verifySignature-cpu-arguments-intercept": number;
                    "unMapData-memory-arguments": number;
                    "mkCons-memory-arguments": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "equalsString-memory-arguments": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "tailList-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "chooseData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "blake2b-memory-arguments": number;
                    "iData-memory-arguments": number;
                    "nullList-memory-arguments": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-slope": number;
                    "trace-memory-arguments": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "cekConstCost-exBudgetCPU": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "mapData-memory-arguments": number;
                    "appendString-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-constant": number;
                    "verifySignature-cpu-arguments-slope": number;
                    "unConstrData-memory-arguments": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "mkPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "verifySignature-memory-arguments": number;
                    "cekLamCost-exBudgetMemory": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                };
            }
        }
        namespace latestParams {
            const collateralPercentage_1: number;
            export { collateralPercentage_1 as collateralPercentage };
            export namespace costModels_1 {
                const PlutusScriptV1: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                };
                const PlutusScriptV2: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "serialiseData-cpu-arguments-intercept": number;
                    "serialiseData-cpu-arguments-slope": number;
                    "serialiseData-memory-arguments-intercept": number;
                    "serialiseData-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEcdsaSecp256k1Signature-cpu-arguments": number;
                    "verifyEcdsaSecp256k1Signature-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-slope": number;
                    "verifySchnorrSecp256k1Signature-memory-arguments": number;
                };
            }
            export { costModels_1 as costModels };
            export namespace executionUnitPrices {
                const priceMemory: number;
                const priceSteps: number;
            }
            const maxBlockBodySize_1: number;
            export { maxBlockBodySize_1 as maxBlockBodySize };
            export namespace maxBlockExecutionUnits {
                const memory: number;
                const steps: number;
            }
            const maxBlockHeaderSize_1: number;
            export { maxBlockHeaderSize_1 as maxBlockHeaderSize };
            const maxCollateralInputs_1: number;
            export { maxCollateralInputs_1 as maxCollateralInputs };
            export namespace maxTxExecutionUnits {
                const memory_1: number;
                export { memory_1 as memory };
                const steps_1: number;
                export { steps_1 as steps };
            }
            const maxTxSize_1: number;
            export { maxTxSize_1 as maxTxSize };
            const maxValueSize_1: number;
            export { maxValueSize_1 as maxValueSize };
            const minPoolCost_1: number;
            export { minPoolCost_1 as minPoolCost };
            export const monetaryExpansion: number;
            export const poolPledgeInfluence: number;
            export const poolRetireMaxEpoch: number;
            export namespace protocolVersion_1 {
                const major_1: number;
                export { major_1 as major };
                const minor_1: number;
                export { minor_1 as minor };
            }
            export { protocolVersion_1 as protocolVersion };
            export const stakeAddressDeposit: number;
            export const stakePoolDeposit: number;
            export const stakePoolTargetNum: number;
            export const treasuryCut: number;
            export const txFeeFixed: number;
            export const txFeePerByte: number;
            export const utxoCostPerByte: number;
        }
        namespace latestTip {
            const epoch: number;
            const hash: string;
            const slot: number;
            const time: number;
        }
    }
    /**
     * Single address wallet emulator.
     * @implements {Wallet}
     */
    export class WalletEmulator implements Wallet {
        /**
         * @param {Network} network
         * @param {NumberGenerator} random - used to generate the private key
         */
        constructor(network: Network, random: NumberGenerator);
        /**
         * @type {Bip32PrivateKey}
         */
        get privateKey(): Bip32PrivateKey;
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @type {Address}
         */
        get address(): Address;
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * Assumed wallet was initiated with at least 1 UTxO at the pubkeyhash address.
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * Simply assumed the tx needs to by signed by this wallet without checking.
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * @implements {Network}
     */
    export class NetworkEmulator implements Network {
        /**
         * @param {number} seed
         */
        constructor(seed?: number);
        /**
         * Create a copy of networkParams that always has access to the current slot
         *  (for setting the validity range automatically)
         * @param {NetworkParams} networkParams
         * @returns {NetworkParams}
         */
        initNetworkParams(networkParams: NetworkParams): NetworkParams;
        /**
         * Creates a WalletEmulator and adds a block with a single fake unbalanced Tx
         * @param {bigint} lovelace
         * @param {Assets} assets
         * @returns {WalletEmulator}
         */
        createWallet(lovelace?: bigint, assets?: Assets): WalletEmulator;
        /**
         * Creates a UTxO using a GenesisTx.
         * @param {WalletEmulator} wallet
         * @param {bigint} lovelace
         * @param {Assets} assets
         */
        createUtxo(wallet: WalletEmulator, lovelace: bigint, assets?: Assets): void;
        /**
         * Mint a block with the current mempool, and advance the slot.
         * @param {bigint} nSlots
         */
        tick(nSlots: bigint): void;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        warnMempool(): void;
        /**
         * Throws an error if the UTxO isn't found
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        dump(): void;
        /**
         * @param {TxInput} utxo
         * @returns {boolean}
         */
        isConsumed(utxo: TxInput): boolean;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * @typedef {() => UplcData} ValueGenerator
     */
    /**
     * @typedef {(args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | Object.<string, boolean>)} PropertyTest
     */
    /**
     * Creates generators and runs script tests
     */
    export class FuzzyTest {
        /**
         * @param {number} seed
         * @param {number} runsPerTest
         * @param {boolean} simplify - if true then also test the simplified program
         */
        constructor(seed?: number, runsPerTest?: number, simplify?: boolean);
        reset(): void;
        /**
         * @returns {NumberGenerator}
         */
        newRand(): NumberGenerator;
        /**
         * Returns a gernator for whole numbers between min and max
         * @param {number} min
         * @param {number} max
         * @returns {() => bigint}
         */
        rawInt(min?: number, max?: number): () => bigint;
        /**
         * Returns a generator for whole numbers between min and max, wrapped with IntData
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        int(min?: number, max?: number): ValueGenerator;
        /**
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        real(min?: number, max?: number): ValueGenerator;
        /**
         * Returns a generator for strings containing any utf-8 character
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        string(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for strings with ascii characters from 32 (space) to 126 (tilde)
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        ascii(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays containing only valid ascii characters
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        asciiBytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays the are also valid utf8 strings
         * @param {number} minLength - length of the string, not of the bytearray!
         * @param {number} maxLength - length of the string, not of the bytearray!
         * @returns {ValueGenerator}
         */
        utf8Bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for number[]
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {() => number[]}
         */
        rawBytes(minLength?: number, maxLength?: number): () => number[];
        /**
         * Returns a generator for bytearrays
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for booleans,
         * @returns {() => boolean}
         */
        rawBool(): () => boolean;
        /**
         * Returns a generator for booleans, wrapped with ConstrData
         * @returns {ValueGenerator}
         */
        bool(): ValueGenerator;
        /**
         * Returns a generator for options
         * @param {ValueGenerator} someGenerator
         * @param {number} noneProbability
         * @returns {ValueGenerator}
         */
        option(someGenerator: ValueGenerator, noneProbability?: number): ValueGenerator;
        /**
         * Returns a generator for lists
         * @param {ValueGenerator} itemGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        list(itemGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for maps
         * @param {ValueGenerator} keyGenerator
         * @param {ValueGenerator} valueGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        map(keyGenerator: ValueGenerator, valueGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for objects
         * @param {...ValueGenerator} itemGenerators
         * @returns {ValueGenerator}
         */
        object(...itemGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Returns a generator for tagged constr
         * @param {number | NumberGenerator} tag
         * @param {...ValueGenerator} fieldGenerators
         * @returns {ValueGenerator}
         */
        constr(tag: number | NumberGenerator, ...fieldGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Run a test
         * @param {ValueGenerator[]} argGens
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>} - throws an error if any of the property tests fail
         */
        test(argGens: ValueGenerator[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        /**
         * @param {Object.<string, ValueGenerator>} paramGenerators
         * @param {string[]} paramArgs
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>}
         */
        testParams(paramGenerators: {
            [x: string]: ValueGenerator;
        }, paramArgs: string[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        #private;
    }
    export type hexstring = string & {};
    /**
     * Needed by transfer() methods
     */
    export type TransferUplcAst = {
        transferByteArrayData: (bytes: number[]) => any;
        transferConstrData: (index: number, fields: any[]) => any;
        transferIntData: (value: bigint) => any;
        transferListData: (items: any[]) => any;
        transferMapData: (pairs: [any, any][]) => any;
        transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any;
        transferSource: (raw: string, name: string) => any;
        transferUplcBool: (site: any, value: boolean) => any;
        transferUplcBuiltin: (site: any, name: string | number) => any;
        transferUplcByteArray: (site: any, bytes: number[]) => any;
        transferUplcCall: (site: any, a: any, b: any) => any;
        transferUplcConst: (value: any) => any;
        transferUplcDataValue: (site: any, data: any) => any;
        transferUplcDelay: (site: any, expr: any) => any;
        transferUplcError: (site: any, msg: string) => any;
        transferUplcForce: (site: any, expr: any) => any;
        transferUplcInt: (site: any, value: bigint, signed: boolean) => any;
        transferUplcLambda: (site: any, rhs: any, name: null | string) => any;
        transferUplcList: (site: any, itemType: any, items: any[]) => any;
        transferUplcPair: (site: any, first: any, second: any) => any;
        transferUplcString: (site: any, value: string) => any;
        transferUplcType: (typeBits: string) => any;
        transferUplcUnit: (site: any) => any;
        transferUplcVariable: (site: any, index: any) => any;
    };
    export type CekValue = UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv;
    export type CekEnv = {
        values: CekValue[];
        callSites: Site[];
    };
    export type ComputingState = {
        computing: UplcTerm;
        env: CekEnv;
    };
    export type ReducingState = {
        reducing: CekValue;
    };
    export type ErrorState = {
        error: string | RuntimeError;
        env: CekEnv;
    };
    export type CekState = ComputingState | ReducingState | ErrorState;
    export type TypeSchema = {
        type: string;
    } | {
        type: "List";
        itemType: TypeSchema;
    } | {
        type: "Map";
        keyType: TypeSchema;
        valueType: TypeSchema;
    } | {
        type: "Option";
        someType: TypeSchema;
    } | {
        type: "Struct";
        fieldTypes: NamedTypeSchema[];
    } | {
        type: "Enum";
        variantTypes: {
            name: string;
            fieldTypes: NamedTypeSchema[];
        }[];
    };
    export type NamedTypeSchema = {
        name: string;
    } & TypeSchema;
    export type ParameterI = {
        name: string;
        typeClass: TypeClass;
    };
    export type InferenceMap = Map<ParameterI, Type>;
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     */
    export type TypeDetails = {
        inputType: string;
        outputType: string;
        internalType: TypeSchema;
    };
    export type JsToUplcHelpers = {
        [name: string]: (obj: any) => Promise<UplcData>;
    };
    export type UplcToJsHelpers = {
        [name: string]: (data: UplcData) => Promise<any>;
    };
    export type JsToUplcConverter = (obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>;
    export type UplcToJsConverter = (data: UplcData, helpers: UplcToJsHelpers) => Promise<any>;
    export type DataType = Named & Type & {
        asDataType: DataType;
        fieldNames: string[];
        offChainType: (null | HeliosDataClass<HeliosData>);
        typeDetails?: TypeDetails;
        jsToUplc: JsToUplcConverter;
        uplcToJs: UplcToJsConverter;
        ready: boolean;
    };
    export type EnumMemberType = DataType & {
        asEnumMemberType: EnumMemberType;
        constrIndex: number;
        parentType: DataType;
    };
    /**
     * EvalEntities assert themselves
     */
    export type EvalEntity = {
        asDataType: (null | DataType);
        asEnumMemberType: (null | EnumMemberType);
        asFunc: (null | Func);
        asInstance: (null | Instance);
        asMulti: (null | Multi);
        asNamed: (null | Named);
        asNamespace: (null | Namespace);
        asParametric: (null | Parametric);
        asType: (null | Type);
        asTyped: (null | Typed);
        asTypeClass: (null | TypeClass);
        toString(): string;
    };
    export type Func = EvalEntity & {
        asTyped: Typed;
        type: Type;
    } & {
        asFunc: Func;
        funcType: FuncType;
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): (null | Typed | Multi);
    };
    export type Instance = Typed & {
        asInstance: Instance;
        fieldNames: string[];
        instanceMembers: InstanceMembers;
    };
    export type Multi = EvalEntity & {
        asMulti: Multi;
        values: Typed[];
    };
    export type Named = EvalEntity & {
        asNamed: Named;
        name: string;
        path: string;
    };
    export type Namespace = EvalEntity & {
        asNamespace: Namespace;
        namespaceMembers: NamespaceMembers;
    };
    export type Parametric = EvalEntity & {
        asParametric: Parametric;
        offChainType: (...any: any[]) => HeliosDataClass<HeliosData>;
        typeClasses: TypeClass[];
        apply(types: Type[], site?: Site): EvalEntity;
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        infer(site: Site, map: InferenceMap): Parametric;
    };
    export type Type = EvalEntity & {
        asType: Type;
        instanceMembers: InstanceMembers;
        typeMembers: TypeMembers;
        isBaseOf(type: Type): boolean;
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        toTyped(): Typed;
        isParametric(): boolean;
    };
    export type Typed = EvalEntity & {
        asTyped: Typed;
        type: Type;
    };
    export type TypeClass = EvalEntity & {
        asTypeClass: TypeClass;
        genInstanceMembers(impl: Type): TypeClassMembers;
        genTypeMembers(impl: Type): TypeClassMembers;
        isImplementedBy(type: Type): boolean;
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    };
    export type InstanceMembers = {
        [name: string]: Type | Parametric;
    };
    export type NamespaceMembers = {
        [name: string]: EvalEntity;
    };
    export type TypeMembers = {
        [name: string]: Type | Typed | Parametric;
    };
    export type TypeClassMembers = {
        [name: string]: Type;
    };
    /**
     * The inner 'any' is also Metadata, but jsdoc doesn't allow declaring recursive types
     * Metadata is essentially a JSON schema object
     */
    export type Metadata = {
        map: [any, any][];
    } | any[] | string | number;
    /**
     * Function that generates a random number between 0 and 1
     */
    export type NumberGenerator = () => number;
    export type CodeMap = [number, Site][];
    export type IRDefinitions = Map<string, IR>;
    export type Decoder = (i: number, bytes: number[]) => void;
    /**
     * Deprecated
     */
    export type HeliosDataClass<T extends HeliosData> = {
        new (...args: any[]): T;
        fromUplcCbor: (bytes: (string | number[])) => T;
        fromUplcData: (data: UplcData) => T;
        isBuiltin(): boolean;
    };
    export type HIntProps = number | bigint;
    export type TimeProps = number | bigint | string | Date;
    export type DurationProps = HIntProps;
    export type BoolProps = boolean | string;
    export type HStringProps = string;
    export type ByteArrayProps = hexstring | number[];
    export type HashProps = hexstring | number[];
    export type DatumHashProps = HashProps;
    export type PubKeyProps = hexstring | number[];
    export type PubKeyHashProps = HashProps;
    export type ScriptHashProps = HashProps;
    export type MintingPolicyHashProps = HashProps;
    export type StakeKeyHashProps = HashProps;
    export type StakingValidatorHashProps = HashProps;
    export type ValidatorHashProps = HashProps;
    export type TxIdProps = HashProps;
    export type TxOutputIdProps = string | [
        TxId | TxIdProps,
        HInt | HIntProps
    ] | {
        txId: TxId | TxIdProps;
        utxoId: HInt | HIntProps;
    };
    /**
     * A valid bech32 string
     */
    export type bech32string = string & {};
    export type AddressProps = bech32string | hexstring | number[];
    export type AssetClassProps = string | [
        MintingPolicyHash | MintingPolicyHashProps,
        ByteArray | ByteArrayProps
    ] | {
        mph: MintingPolicyHash | MintingPolicyHashProps;
        tokenName: ByteArray | ByteArrayProps;
    };
    export type AssetsProps = [
        AssetClass | AssetClassProps,
        HInt | HIntProps
    ][] | [
        MintingPolicyHash | MintingPolicyHashProps,
        [
            ByteArray | ByteArrayProps,
            HInt | HIntProps
        ][]
    ][];
    export type ValueProps = HInt | HIntProps | [
        HInt | HIntProps,
        Assets | AssetsProps
    ] | {
        lovelace: HInt | HIntProps;
        assets?: Assets | AssetsProps;
    };
    export type Cost = {
        mem: bigint;
        cpu: bigint;
    };
    export type LiveSlotGetter = () => bigint;
    export type CostModelClass = {
        fromParams: (params: NetworkParams, baseName: string) => CostModel;
    };
    /**
     * A Helios/Uplc Program can have different purposes
     */
    export type ScriptPurpose = "testing" | "minting" | "spending" | "staking" | "linking" | "module" | "unknown";
    export type UplcRawStack = [null | string, UplcValue][];
    export type UplcRTECallbacks = {
        onPrint: (msg: string) => Promise<void>;
        onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>;
        onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>;
        onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void;
    };
    export type UplcRTECallbacksInternal = UplcRTECallbacks & {
        macros?: {
            [name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>;
        };
    };
    export type UplcAnonCallback = (callSite: Site, subStack: UplcStack, ...args: UplcValue[]) => (UplcValue | Promise<UplcValue>);
    export type UplcAnonProps = {
        rte: UplcRte | UplcStack;
        nArgs?: number;
        argNames?: string[];
        argCount?: number;
        fn: UplcAnonCallback;
        callSite?: Site;
        allowAnyArgs?: boolean;
    };
    /**
     * TODO: purpose as enum type
     */
    export type ProgramProperties = {
        purpose: null | ScriptPurpose;
        callsTxTimeRange: boolean;
        name?: string;
    };
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     */
    export type TransferableUplcProgram<TInstance> = {
        transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance;
        transferUplcAst: TransferUplcAst;
    };
    /**
     * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
     * cpu:  in reference cpu microseconds
     * size: in bytes
     * builtins: breakdown per builtin
     * terms: breakdown per termtype
     * result: result of evaluation
     * messages: printed messages (can be helpful when debugging)
     */
    export type Profile = {
        mem: bigint;
        cpu: bigint;
        size?: number;
        builtins?: {
            [name: string]: Cost;
        };
        terms?: {
            [name: string]: Cost;
        };
        result?: RuntimeError | UplcValue;
        messages?: string[];
    };
    export type GenericTypeProps<T extends HeliosData> = {
        name: string;
        path?: string;
        offChainType?: HeliosDataClass<T> | null;
        genOffChainType?: (() => HeliosDataClass<T>) | null;
        fieldNames?: string[];
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers: (self: Type) => TypeMembers;
        genTypeDetails?: (self: Type) => TypeDetails;
        jsToUplc?: JsToUplcConverter;
        uplcToJs?: UplcToJsConverter;
    };
    export type GenericEnumMemberTypeProps<T extends HeliosData> = {
        name: string;
        path?: string;
        constrIndex: number;
        parentType: DataType;
        offChainType?: HeliosDataClass<T>;
        genOffChainType?: () => HeliosDataClass<T>;
        fieldNames?: string[];
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers?: (self: Type) => TypeMembers;
        genTypeDetails?: (self: Type) => TypeDetails;
        jsToUplc?: JsToUplcConverter;
        uplcToJs?: UplcToJsConverter;
    };
    export type ScriptTypes = {
        [name: string]: ScriptHashType;
    };
    export type IRLiteralRegistry = Map<IRVariable, IRLiteralExpr>;
    export type UserTypes = {
        [name: string]: any;
    };
    export type ProgramConfig = {
        allowPosParams: boolean;
        invertEntryPoint: boolean;
    };
    export type PrivateKey = {
        derivePubKey(): PubKey;
        sign(msg: number[]): Signature;
    };
    export type CoinSelectionAlgorithm = (utxos: TxInput[], amount: Value) => [TxInput[], TxInput[]];
    export type Wallet = {
        isMainnet(): Promise<boolean>;
        usedAddresses: Promise<Address[]>;
        unusedAddresses: Promise<Address[]>;
        utxos: Promise<TxInput[]>;
        collateral: Promise<TxInput[]>;
        signTx(tx: Tx): Promise<Signature[]>;
        submitTx(tx: Tx): Promise<TxId>;
    };
    export type Cip30Handle = {
        getNetworkId(): Promise<number>;
        getUsedAddresses(): Promise<string[]>;
        getUnusedAddresses(): Promise<string[]>;
        getUtxos(): Promise<string[]>;
        getCollateral(): Promise<string[]>;
        signTx(txHex: string, partialSign: boolean): Promise<string>;
        submitTx(txHex: string): Promise<string>;
        experimental: {
            getCollateral(): Promise<string[]>;
        };
    };
    export type Network = {
        getUtxos(address: Address): Promise<TxInput[]>;
        getUtxo(id: TxOutputId): Promise<TxInput>;
        getParameters(): Promise<NetworkParams>;
        submitTx(tx: Tx): Promise<TxId>;
    };
    /**
     * collectUtxos removes tx inputs from the list, and appends txoutputs sent to the address to the end.
     */
    export type EmulatorTx = {
        id(): TxId;
        consumes(utxo: TxInput): boolean;
        collectUtxos(address: Address, utxos: TxInput[]): TxInput[];
        getUtxo(id: TxOutputId): (null | TxInput);
        dump(): void;
    };
    export type ValueGenerator = () => UplcData;
    export type PropertyTest = (args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | {
        [x: string]: boolean;
    });
    /**
     * UplcStack contains a value that can be retrieved using a Debruijn index.
     */
    class UplcStack {
        /**
         * @param {null | UplcStack | UplcRte} parent
         * @param {null | UplcValue} value
         * @param {null | string} valueName
         */
        constructor(parent: null | UplcStack | UplcRte, value?: null | UplcValue, valueName?: null | string);
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * Gets a value using the Debruijn index. If 'i == 1' then the current value is returned.
         * Otherwise 'i' is decrement and passed to the parent stack.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         *
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Instantiates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the onPrint callback in the RTE (root of stack).
         * @param {string} msg
         * @returns {Promise<void>}
         */
        print(msg: string): Promise<void>;
        /**
         * Calls the onStartCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcLambda>}
     */
    class UplcLambdaWithEnv extends UplcTermWithEnv<UplcLambda> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcLambda, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * @internal
     */
    class AppliedUplcBuiltin {
        /**
         * @param {UplcBuiltin} term
         * @param {number} forceCount
         * @param {CekValue[]} args
         */
        constructor(term: UplcBuiltin, forceCount?: number, args?: CekValue[]);
        /**
         * @readonly
         * @type {UplcBuiltin}
         */
        readonly term: UplcBuiltin;
        /**
         * @readonly
         * @type {number}
         */
        readonly forceCount: number;
        /**
         * @readonly
         * @type {CekValue[]}
         */
        readonly args: CekValue[];
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {AppliedUplcBuiltin}
         */
        force(): AppliedUplcBuiltin;
        /**
         * @param {CekValue} arg
         * @returns {AppliedUplcBuiltin}
         */
        apply(arg: CekValue): AppliedUplcBuiltin;
        /**
         * @returns {boolean}
         */
        isFullForced(): boolean;
        /**
         * @returns {boolean}
         */
        isFullyApplied(): boolean;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site[]} sites
         * @returns {Promise<CekValue>}
         */
        evalCek(rte: UplcRte, sites: Site[]): Promise<CekValue>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         *
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * Parent class of EnumSwitchExpr and DataSwitchExpr
     */
    class SwitchExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} controlExpr - input value of the switch
         * @param {SwitchCase[]} cases
         * @param {null | SwitchDefault} defaultCase
        */
        constructor(site: Site, controlExpr: Expr, cases: SwitchCase[], defaultCase?: null | SwitchDefault);
        get controlExpr(): Expr;
        get cases(): SwitchCase[];
        get defaultCase(): SwitchDefault;
        /**
         * If there isn't enough coverage then we can simply set the default case to void, so the other branches can be error, print or assert
         */
        setDefaultCaseToVoid(): void;
        #private;
    }
    /**
     * A Module is a collection of statements
     */
    class Module {
        /**
         * @param {string} rawSrc
         * @returns {Module}
         */
        static new(rawSrc: string): Module;
        /**
         * @param {Word} name
         * @param {Statement[]} statements
         */
        constructor(name: Word, statements: Statement[]);
        throwErrors(): void;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {Statement[]}
         */
        get statements(): Statement[];
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {ModuleScope} scope
         */
        evalTypes(scope: ModuleScope): void;
        /**
         * This module can depend on other modules
         * TODO: detect circular dependencies
         * @param {Module[]} modules
         * @param {Module[]} stack
         * @returns {Module[]}
         */
        filterDependencies(modules: Module[], stack?: Module[]): Module[];
        #private;
    }
    /**
     * The entrypoint module
     */
    class MainModule extends Module {
        /**
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcDelay>}
     */
    class UplcDelayWithEnv extends UplcTermWithEnv<UplcDelay> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcDelay, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * @internal
     * @template {UplcTerm} T
     */
    class UplcTermWithEnv<T extends UplcTerm> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: T, env: CekEnv);
        /**
        * @readonly
        * @type {T}
        */
        readonly term: T;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
        /**
         * @type {Site}
         */
        get site(): Site;
        toString(): string;
    }
    export {};
}
